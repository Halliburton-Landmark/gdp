		GLOBAL DATAPLANE INTERFACES

This directory contains a very poor prototype of the Global Dataplane
(GDP) with two bindings.  The first is for C, and the second is a
HTTP-based RESTful interface.  The first is used to implement the
second.  All of these are likely to change in the future.

Getting Started:
    These are a "quick start" guide to running the GDP.  Details are
    all included below.

   1.	Install the prerequisite packages described below.  For the base
	system all you'll need are libevent2-dev and libssl-dev, but the
	others are needed for full functionality.

   2.	Compile the code as described below.

   3.	Create the directory /var/tmp/gcl.  This is where the data
	files are kept.  It should be owned by whatever user will be
	running gdpd.  For security reasons, this should NOT be root!!
	You can change the name of this directory by setting the
	administrative parameter "swarm.gdplogd.gcl.dir", as described
	toward the end of this document.

   4.	Adjust any administrative parameters (see below).  In particular,
	you may want to update swarm.gdplogd.gdpname so that the log
	daemon has the same name every time it starts up (otherwise it
	will choose a random name).  In any case, it will print its own
	name when it starts up.

   5.	Start the GDP routing daemon (routia).

   6.	Start the GDP log daemon (see above).  Make note of its "GDP
	routing name" for use in the next step.

   7.	Create your first GCL using apps/gcl-create.  It takes two
	arguments: the name of the log daemon on which to create the
	GCL (as displayed in the previous step) and the name of the new
	log.  If the second parameter is omitted an internal name is
	used.

   8.	Run apps/writer-test giving it the name of the log you just
	created to add data to the log.  It will ask for lines of input
	that are appended ot the log.  There is no need to give the
	name of the log daemon; routia will find it for you.

   9.	Check success by running apps/reader-test giving it the
	same name as you used in the previous step.


Required Packages:

	libevent2 --- Event handling library available from
		http://libevent.org.  Most systems (Linux, MacOS, and
		FreeBSD at a minumum) have this available as a package.
		On Debian-derived linux systems (Debian, Ubuntu, etc.)
		you have to install the package libevent-dev; on
		some other systems (e.g., RHEL 6, which only has
		libevent1) you'll have to download directly from
		http://libevent.org and install.
	libssl-dev --- for the sha256 implementation.
	lighttpd --- Web server for RESTful interface.
		Note: I used macports (http://macports.org) to install
		lighttpd on the Mac, which is probably easier than compiling
		it by hand; in particular, it does the Mac-specific
		configuration for you.
	scgilib --- C binding for Simple Common Gateway Interface: to connect
		lighttpd with GDP.  It is included (with some local patches)
		with this distribution.  For the original version, see
		http://www.xamuel.com/scgilib/.
	Jansson --- JSON library from http://www.digip.org/jansson/.
		On Linux it can be installed as the libjansson-dev package.
		On MacOS and FreeBSD it is the "jansson" port or pkg.

	To install these, use the following commands:
	On the Mac:
	    sudo port install libevent openssl lighttpd jansson
	On FreeBSD:
	    sudo pkg install libevent2 openssl lighttpd jansson
	On Ubuntu/Linux:
	    sudo apt-get install libevent-dev libssl-dev \
			lighttpd libjansson-dev

Compiling:
	First, install the prerequisite packages.

	Should just be a matter of typing "make" in the root.
	Note: gcc on linux has a bug that causes it to complain about
	non-constant expressions in an initializer when the -std=c99
	flag is given.  Those same expressions are constant in Clang
	and even in gcc without the -std=c99 flag.  As a result of
	this problem, we don't use the -std=c99 flag by default, but
	this means that not all features of C99 are available.
	If you want full C99, use "STD=-std=c99" on the make command
	line.

	As of this writing, GDP works on MacOS 10.9 (using clang),
	Ubuntu 12.04 (using gcc or clang), and Freebsd 10.0 (using
	clang).  I believe at least one person has it running on
	MacOS 10.7 using gcc.

        Note, the lang/js/ JavaScript system currently must be built
        separately using the target all_JavaScript in gdp/Makefile:
            make all_JavaScript
        To clean (including removing a rather extensive set of Node.js
        modules which are installed by all_JavaScript):
            make clean_JavaScript

Running a GDP-based program:
	For anything interesting to happen, two daemons must be
	running.  The first is the routing layer, currently a
	Python application named Routia.  It currently uses a simple
	"global knowledge" algorithm where every routing node knows
	every name known by the system.  Names include running servers
	and applications as well as logs.  Everything else connects
	into the routing layer.

	The second is gdplogd, which implements physical on-disk
	logs.  It must be started after the routing layer.
	Located in gdplogd/gdplogd, it takes these parameters:
	   -D<debug-spec>
		Turn on debugging.  See "Setting Debug Flags" below
		for more information.  Implies -F.
	   -F	Run in foreground.  At the moment, gdpd always runs
		in foreground, but the intent is that it will default
		to background mode without this flag.
	   -G<gdp-addr>
		Use <gdp-addr> as the address of the routing layer
		daemon.  Defaults to localhost:8007.  Can also be set
		with the "swarm.gdp.ip_addr" administrative parameter.
		See "Changing Parameters" below for more information.
	   -n<workers>
		Start up <workers> worker threads.  Defaults to a
		minimum of one thread which can expand up to twice
		the number of cores available.  Can also be set (with
		finer control) using the libep.thr.pool.min_workers
		and libep.thr.pool.max_workers parameters.

	You also have to create the directory "/var/tmp/gcl" to store
	the data repository.

	In many cases, GDP programs will try to reconnect if a
	component (gdplogd, routia) goes down, but they must all be
	up and running before they will start in the first place.

Subscriptions:
	You can "subscribe" to a GCL, which will produce an output
	whenever that GCL has a record written to it.  To subscribe,
	use "apps/reader-test -s <name>".

Running the GDP RESTful Interface:
	(In these instructions, <gcl-name> is a URI-base-64-encoded
	string of length 43 characters.  A <recno> is a positive
	non-zero integer.)

   1.	Do the "Getting Started" steps described above.

   2.	The instructions for SCGI configuration for lighttpd are totally
	wrong.  The configuration file you actually need is:

		server.modules += ( "mod_scgi" )

		#scgi.debug = 10
		scgi.server = (
		    "/gdp/v1/" =>
			( "gdp" =>
			    ( "host"  => "127.0.0.1",
			      "port" => 8001,
			      "check-local" => "disable",
			    )
			)
		    )

	(Normally in /usr/local/etc/lighttpd/conf.c/scgi.conf) This will
	tell lighttpd to connect to an SCGI server on the local machine,
	port 8001.  You'll also need to make sure the line
	"include conf.d/scgi.conf" in /usr/local/etc/lighttpd/modules.conf
	is not commented out.  The rest of the lighttpd setup should be
	off the shelf.  I've set up instance of lighttpd to listen on
	port 8080 instead of the default port 80, and the rest of these
	instructions will reflect that.

   3.	Start up the GDP RESTful interface server in apps/gdp-rest.
	It will run in foreground and spit out some debugging
	information.  For even more, use -D\*=20 on the command
	line.  This sets all debug flags to level 20.  The backslash
	is just to keep the Unix shell from trying to glob the
	asterisk.

   4.	Start the lighttpd server, for example using:
	"lighttpd -f /usr/local/etc/lighttpd/lighttpd.conf -D".
	This assumes that your configuration is in
	/usr/local/etc/lighttpd.  The -D says to run in foreground
	and you can skip it if you want.  You may want to turn on
	some debugging inside the daemon to help you understand the
	interactions.  See .../etc/lighttpd/conf.d/debug.conf.

   5.	The actual URIs and methods used by the REST interface are
	described in doc/gdp-rest-interface.html.  See that for
	details.

	You can do GETs from inside a browser such as Firefox or
	Chrome, but not POSTs.  To use other methods you'll have to
	use Chrome.  Install the "postman" extension to enable
	sending of arbitrary methods such as POST and PUT.

Changing Parameters:
	If you want to change parameters such as socket numbers or the
	GCL directory you can do so without recompiling.  Configuration
	files are simple "name=value" pairs, one per line.  There is
	a built-in search path ".ep_adm_params:~/.ep_adm_params:\
	/usr/local/etc/ep_adm_params:/etc/ep_adm_params"
	that can be overridden the EP_PARAM_PATH environment variable.
	Those directories are searched for files named "gdplogd" (for
	gdplogd only), "gdp" (for all programs that use the GDP), or
	"defaults" (for all programs).

	There are many parameters you change, as described below.  In
	most cases, the ones you are likely to find interesting (and
	the files in which they should probably live) are:
		swarm.gdp.routers		gdp
		swarm.gdplogd.gcl.dir		gdplogd
		swarm.gdplogd.gdpname		gdplogd

	swarm.gdp.routers --- the address(es) of the gdp routing layer
		(used by clients).  Multiple addresses can be included,
		separated by semicolons.  If no port is included, it
		defaults to 8007.  This will eventually be replaced by
		service discovery.  Defaults to 127.0.0.1:8007.
	swarm.gdp.event.loopdelay --- if the event loop exits for some
		reason, this is the number of microseconds to delay
		before restarting the loop.  Defaults to 100000 (100msec).
	swarm.gdp.event.looptimeout --- the timeout for the event loop;
		this is mostly just to make sure things don't "hang up"
		forever.  Defaults to 30 (seconds).
	swarm.gdp.connect.timeout --- how long to wait for a connection
		to the GDP routing layer before giving up and trying
		another entry point (in milliseconds).  Defaults to
		10000 (ten seconds).
	swarm.gdp.reconnect.delay --- the number of milliseconds to wait
		before attempting to reconnect if the routing layer is
		disconnected.  Defaults to 100 milliseconds.
	swarm.gdp.invoke.timeout --- the number of milliseconds to wait
		for a response before timing out a GDP request.  Defaults
		to 10000 (ten seconds).
	swarm.gdp.invoke.retries --- the number of times to re-send a
		request when no response is received.  Defaults to 3
		(meaning that the request may be sent up to 4 times
		total).
	swarm.gdp.log.facility --- the name of the log facility to use
		(see syslog(3) for details).  The "gdp" in the name
		can be replaced by an individual program name to set a
		value that applies only to that program, e.g.,
		"swarm.gdplogd.log.facility".  If both are set, the more
		specific name wins.  Defaults to "local4".
	swarm.gdplogd.gcl.dir --- the data directory (e.g., /var/tmp/gcl).
		Defaults to "/var/tmp/gcl".
	swarm.gdplogd.reclaim.interval --- how often to wake up to
		reclaim unused resources.  Defaults to 15 (seconds).
	swarm.gdplogd.gcl.reclaim-age --- how long a GCL is permitted to
		sit idle before its resources are reclaimed.  Defaults
		to 300 (seconds, i.e., five minutes).
	swarm.gdplogd.gdpname --- the name to use as the source address
		for protocol initiating from this program.  If not set,
		a random name is made up when the program is started.
		Generally speaking, you will want to set this parameter;
		I recommend reverse-dns addresses, e.g.,
		swarm.gdplogd.gdpname=edu.berkeley.eecs.gdp-01.gdplogd.
	swarm.rest.prefix --- the REST prefix (e.g., /gdp/v1/).
	swarm.rest.scgi.port --- the port number for the SCGI server to
		listen on.  If you change this you'll also have to
		change the lighttpd configuration.  Defaults to 8001.
	swarm.rest.scgi.pollinterval --- how often to poll for SCGI
		connections (in microseconds).  Defaults to 100000
		(100 msec).
	swarm.rest.kv.gclname --- the name of the GCL to use for the
		key-value store.  Defaults to "sys/kv/KeyValStore".
	libep.time.accuracy --- the value filled in for the "accuracy"
		field in time structures (defaults to zero).
	libep.thr.pool.min_workers --- the default minimum number of
		worker threads in the thread pool.  If not specified
		the default is 1.  It can be overridden by the calling
		application.
	libep.thr.pool.max_workers --- the default maximum number of
		worker threads in the thread pool.  If not specified
		the default is two times the number of available
		cores.  It can be overridden by the calling application.

Setting Debug Flags:
	You can turn on debugging output using a command line flag,
	conventionally "-D<pattern>=<level>".  The <pattern> specifies
	which flags should be set and <level> specifies how much
	should be printed; zero indicates no output, and more output
	is added as the values increase.

	By convention <level> is no greater than 127, and values 100
	and above may modify the base behavior of the program (i.e.,
	do more than just printing information).

	Each debug flag has a hierarchical name with (by convention)
	"." as the separator, for example, "gdp.proto" to indicate
	the protocol processing of the GDP.  The "what(1)" program on
	a binary will show you which debug flags are available
	including a short description.

Directory Structure:
	ep --- A library of C utility functions.  This is a stripped
		down version of a library I wrote several years ago.
		If you look at the code you'll see vestiges of some
		of the stripped out functions.  I plan on cleaning
		this version up and releasing it again.
	gdp --- A library for GDP manipulation.  This is the library
		that applications must link to access the GDP.
	gdplogd --- The GDP log daemon.  This implements physical
		(on disk) logs for the GDP.  The implementation is
		still fairly simplistic.  It depends on a routing
		layer (currently routia, in a separate repository).
	scgilib --- An updated version of the SCGI code from
		http://www.xamuel.com/scgilib/.  SCGI permits a
		web server to access outside programs by opening
		a socket in a manner much more efficient than basic
		CGI fork/exec.  This is only used for the REST interface.
	apps --- Application programs, including tests.
	doc --- Some documentation, woefully incomplete.
	lang --- sub-directories with language-specific application
                programs and supporting code.
        lang/js --- JavaScript-specific apps and libraries.  Also contains
                the Node.js/JS GDP RESTful interface code.  See associated
                README files for details.
        lang/python --- Python-specific apps and libraries.
