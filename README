		GLOBAL DATAPLANE INTERFACES

This directory contains a very basic prototype of the Global Dataplane
(GDP) with two bindings.  The first is for C, and the second is a
HTTP-based RESTful interface.  The first is used to implement the
second.  All of these are likely to change in the future.

NOTE: these instructions assume you are starting with the source
distribution.  This is not appropriate if you are installing the
debian package.

Getting Started:
    These are a "quick start" guide to running the GDP.  Details are
    all included below.

   0.a)	Get the code for log server (gdplogd) using one of:
	    git clone \
		https://repo.eecs.berkeley.edu/git/projects/swarmlab/gdp.git
	or
	    git clone \
		repoman@repo.eecs.berkeley.edu:projects/swarmlab/gdp.git
	For the moment that repository is not open; contact Eric to get
	access.

     b)	(Optional) Get the code for GDP router (gdp_router) using:
	    git clone https://github.com/niteshmor/gdp_router.git
	(This is a public repository.)
	This step is required only if you intend to run a GDP router. For
	the moment, it is highly recommended that you do not run your own
	instance of gdp_router.

   1.	Install the prerequisite packages described below.  For the base
	system all you'll need are libevent2-dev and libssl-dev, but the
	others are needed for full functionality.

   2.	Compile the code as described below.

   3.	Create the directory /var/swarm/gcls.  This is where the data
	files are kept.  It should be owned by whatever user will be
	running gdplogd.  For security reasons, this should NOT be root!!
	(Although you will probably have to be root in order to create
	this directory in the first place.) You can change the name
	of this directory at runtime by setting the administrative
	parameter "swarm.gdplogd.gcl.dir", as described toward the
	end of this document.

   4.	Adjust any administrative parameters (see below).  In particular,
	you may want to update swarm.gdplogd.gdpname so that the log
	daemon has the same name every time it starts up (otherwise it
	will choose a random name).  In any case, it will print its own
	name when it starts up.

   5.	(Optional) Start the GDP routing daemon (gdp_router).

   6.	Start the GDP log daemon (see above).  Make note of its "GDP
	routing name" for use in the next step.

   7.	Create your first GCL using apps/gcl-create.  It takes two
	arguments: the name of the log daemon on which to create the
	GCL (as displayed in the previous step) and the name of the new
	log.  If the second parameter is omitted an internal name is
	used.

   8.	Run apps/writer-test giving it the name of the log you just
	created to add data to the log.  It will ask for lines of input
	that are appended ot the log.  There is no need to give the
	name of the log daemon; gdp_router will find it for you.

   9.	Check success by running apps/reader-test giving it the
	same name as you used in the previous step.


Required Packages:

	libevent2 --- Event handling library available from
		http://libevent.org.  Most systems (Linux, MacOS, and
		FreeBSD at a minumum) have this available as a package.
		On Debian-derived linux systems (Debian, Ubuntu, etc.)
		you have to install the package libevent-dev; on
		some other systems (e.g., RHEL 6, which only has
		libevent1) you'll have to download directly from
		http://libevent.org and install.
	libssl-dev --- for the sha256 implementation.
	lighttpd --- Web server for RESTful interface.
		Note: I used macports (http://macports.org) to install
		lighttpd on the Mac, which is probably easier than compiling
		it by hand; in particular, it does the Mac-specific
		configuration for you.
	scgilib --- C binding for Simple Common Gateway Interface: to connect
		lighttpd with GDP.  It is included (with some local patches)
		with this distribution.  For the original version, see
		http://www.xamuel.com/scgilib/.
	Jansson --- JSON library from http://www.digip.org/jansson/.
		On Linux it can be installed as the libjansson-dev package.
		On MacOS and FreeBSD it is the "jansson" port or pkg.

	To install these, use the following commands:
	    On the Mac:
		sudo port install libevent openssl lighttpd jansson
	    On FreeBSD:
		sudo pkg install libevent2 openssl lighttpd jansson
	    On Ubuntu/Linux:
		sudo apt-get install libevent-dev libssl-dev \
			lighttpd libjansson-dev
	    On Gentoo/Linux:
		sudo emerge openssl libevent lighttpd jansson
	Or, use the helper script adm/gdp-setup.sh, which should work
	on all these platforms.

Compiling the GDP Code:
	First, install the prerequisite packages.

	Compiling should just be a matter of typing "make" in the root.

	Note: gcc on linux has a bug that causes it to complain about
	non-constant expressions in an initializer when the -std=c99
	flag is given.  Those same expressions are constant in Clang
	and even in gcc without the -std=c99 flag.  As a result of
	this problem, we don't use the -std=c99 flag by default, but
	this means that not all features of C99 are available.
	If you want full C99, use "STD=-std=c99" on the make command
	line.

	Further note: At least some versions of gcc give warnings
	about ignored return values even when the function call has
	been explicitly voided.  We know about this and do not
	consider it to be a bug in the GDP code.  If these warnings
	bother you we recommend installing clang and using that
	compiler.  (Hint: it gives much better error messages and
	catches things that gcc does not.)

	As of this writing, GDP works on MacOS 10.9 (using clang),
	Ubuntu 14.04 (using gcc or clang), and Freebsd 10.0 (using
	clang).  I believe at least one person has it running on
	MacOS 10.7 using gcc.

	NOTA BENE: JavaScript support in lang/js currently has no one
	to support it, so it may require extra work to get it going.
	It must be built separately using:
            make all_JavaScript
        To clean (including removing a rather extensive set of Node.js
        modules which are installed by all_JavaScript):
            make clean_JavaScript

Create Log Directory:
	If you are using the log servers at Berkeley you can skip
	this step.

	You'll have to select a location to store the log data.  For
	obvious reasons this should be on a filesystem that has a
	reasonable amount of free space.  The default is
	/var/swarm/gcls.  You'll probably have to be root to
	create this directory:
		sudo mkdir -p /var/swarm/gcls

	Create a user (or choose an existing user) to own the on-disk
	files.  These instructions will assume a new user named
	gdp, group gdp; on Debian/Ubuntu:
		sudo adduser --system --group gdp

	The directory should be mode 700 or 750, owned by gdp:gdp:
		sudo chmod 750 /var/swarm/gcls
		sudo chown gdp:gdp /var/swarm/gcls
	Mode 750 is just to allow users in the gdp group to be able
	to peek into the directory.  This should be limited to
	people who are maintaining the GDP.

Adjust Administrative Parameters:
	If you want to change parameters such as socket numbers or the
	GCL directory you can do so without recompiling.  Configuration
	files are simple "name=value" pairs, one per line.  There is
	a built-in search path ".ep_adm_params:~/.ep_adm_params:\
	/usr/local/etc/ep_adm_params:/etc/ep_adm_params"
	that can be overridden the EP_PARAM_PATH environment variable.
	(Note: if a program is running setuid then only the two
	system paths are searched, and EP_PARAM_PATH is ignored.)
	Those directories are searched for files named "gdplogd" (for
	gdplogd only), "gdp" (for all programs that use the GDP), or
	"defaults" (for all programs).

	There are many parameters you change, as described near the
	end of this README.  In most cases, the ones you are likely
	to find interesting (and the files in which they should
	probably live) are:
	    swarm.gdp.routers			gdp
	    	A semicolon-separated list of host names or IP
		addresses to search to find a running routing node.
		This defaults to 127.0.0.1.  If you have a local
		routing node you should name it first, followed
		by "gdp-01.eecs.berkeley.edu; gdp-02.eecs.berkeley.edu"
		(these are run by us for your convenience).
	    swarm.gdplogd.gcl.dir		gdplogd
	    	This is the name of the directory you created in
		the previous step.  It only applies on nodes that
		are running a log daemon.
	    swarm.gdplogd.gdpname		gdplogd
	    	This is a user-friendly name for the name of the
		log daemon.  You'll need this for creating GCLs,
		as described below.  If you don't specify this,
		the name is chosen randomly each time gdplogd
		starts up.
	Example:
	    In file /usr/local/etc/ep_adm_params/gdp:
		swarm.gdp.routers=mygdp.example.com; \
		    gdp-01.eecs.berkeley.edu; gdp-02.eecs.berkeley.edu
	    In file /usr/local/etc/ep_adm_params/gdplogd:
		swarm.gdplogd.gcl.dir=/home/gdp/data/gcls
		swarm.gdplogd.gdpname=com.example.mygdp.gdplogd
	    [The first example is line wrapped to fit; when you create
	    the file it must be on one line.]

Start the GDP Routing Daemon:
	If you are using the routing daemons at Berkeley you can skip
	this step. It is highly recommended that you do not run your
	own gdp_router at the moment.

	Currently, gdp_router is in it's own separate repository at:
	    https://github.com/niteshmor/gdp_router.git
	This will be moved to some place else in near future.

	The current version of the routing daemon uses a simple
	"global knowledge" algorithm where every routing node knows
	every name known by the system.  Names include running servers
	and applications as well as logs.  Because of this, every
	routing server **must** be talking with every other routing
	server.  [This restriction will be relaxed in the future.]

	To run your own, you'll have to make sure you know the address
	of all other routing nodes in the GDP.  This is a temporary
	situation, but for now it is critical that all routing nodes
	know about all other routing nodes.  To do this you'll have to
	get the current list of nodes (gdp-routers.list), add your
	information to that list, and make sure that list gets updated
	on all the nodes.  For now we'll maintain that master list at
	Berkeley.

	Once you have the list of routers you'll need to start the
	Python program "gdp-router.py".  It takes several parameters
	which are described in detail in gdp_router/README.md.  The most
	important flag is "-r", which takes the list of known
	routers as the argument.  For example:

	    gdp-router.py -r gdp-routers.list

Start the GDP Log Daemon:
	If you are using the log servers at Berkeley you can skip
	this step.

	The program gdplogd implements physical on-disk logs.  It must
	be started after the routing layer.  Located in gdplogd/gdplogd,
	it takes these parameters:
	   -D<debug-spec>
		Turn on debugging.  See "Setting Debug Flags" below
		for more information.  Implies -F.
	   -F	Run in foreground.  At the moment, gdpd always runs
		in foreground, but the intent is that it will default
		to background mode without this flag.
	   -G<gdp-addr>
		Use <gdp-addr> as the address of the routing layer
		daemon.  Defaults to localhost:8007.  Can also be set
		with the "swarm.gdp.ip_addr" administrative parameter.
		See "Changing Parameters" below for more information.
	   -n<workers>
		Start up <workers> worker threads.  Defaults to a
		minimum of one thread which can expand up to twice
		the number of cores available.  Can also be set (with
		finer control) using the libep.thr.pool.min_workers
		and libep.thr.pool.max_workers parameters.

Create a GCL:
	We have pre-created some logs at Berkeley you can use if
	you want to skip this step.  Those logs are named
	swarm/demo/<inst>/00 through swarm/demo/<inst>/09,
	where <inst> is the name of your institution (we'll create
	these for you on request).  There is an "instiution" named
	"play" that you can use as well, but you'll be sharing them
	with everyone else, and the data may not persist.

	To create your own logs you'll need the GDP name (_not_ the
	DNS name) of the log server that will store the log.  This
	can be set as an administrative parameter, and the internal
	form is printed out as the log server starts up.  We'll run
	three log servers at Berkeley you can use:

		edu.berkeley.eecs.gdp-01.gdplogd
		edu.berkeley.eecs.gdp-02.gdplogd
		edu.berkeley.eecs.gdp-03.gdplogd

	You'll also need to select a name for your log.  We
	recommend using a name that is unlikely to clash with other
	logs, either similar to the gdplogd example above or using
	<inst>/<project>/<name>.  For example either

		edu.berkeley.eecs.swarmlab.sensor23
		berkeley/swarmlab/sensor/23

	would be reasonable choices.  To actually create the log on
	a given server, use

		gcl-create <server> <logname>

	For example:

		gcl-create edu.berkeley.eecs.gdp-01.gdplogd \
			berkeley/swarmlab/sensor/23

	The good news is that this the only time you'll need to know
	the name of the log server.

Running GDP-based Programs:
	There are two test programs included with the GDP: reader-test
	and writer-test.  There are also some demo programs you can
	copy and adapt for your own use.  The descriptions given
	below do not include all of the command line flags; these are
	just the ones that are most useful.

	Note that both the routing and the log daemons must be running
	before a GDP program can start up.  In many cases, GDP programs
	will try to reconnect if a component (gdplogd, gdp_router) goes
	down, but they must all be up and running before they will start
	in the first place.

	The writer-test program reads records from the standard input
	and writes to the target log.  It is invoked as:

	    writer-test [-D dbgspec] [-G router-addr] gcl-name

	The -D flag turns on debugging output and is described below.
	The -G flag overrides the swarm.gdp.routers parameter.  The
	gcl-name is the name of the GCL to be appended to.  Lines are
	read from the input and written to the log, where each input
	line creates one log record.

	The reader-test program reads records from the log and writes
	them to the standard output.  It is invoked as:

	    reader-test [-D dbgspec] [-f firstrec] [-G router-addr] \
	    	[-m] [-M] [-n nrecs] [-s] gcl-name

	The -D and -G flags are the same as writer-test.  The -f and
	-n flags specify the first record number (starting from 1) and
	the maximum number of records to read.  There are three ways
	reader-test can operate.  By default, it reads the records
	one at a time in separate read requests.  The -m flag changes
	this to "multiread" mode, where the records are delivered in
	a more efficient way --- essentially, the multiread command
	returns success and then the data records are sent after the
	command acknowledgement.  The -s flag turns on subscription
	mode, which is like -m except that the log daemon will wait
	until new records are added and deliver them spontaneously to
	subscribers.  For example:

	    reader-test -f 1 -s eric/sensor45

	will return all the data already recorded in the log and then
	wait until more data is written; the new data will be
	immediately printed.  If -m were used instead of -s then
	all the existing data would be returned, and then it would
	exit.  If -s were used without -f, no existing data would
	be printed, only new data.

Running the GDP RESTful Interface:
	(In these instructions, <gcl-name> is a URI-base-64-encoded
	string of length 43 characters.  A <recno> is a positive
	non-zero integer.)

   1.	Do the "Getting Started" steps described above.

   2.	The instructions for SCGI configuration for lighttpd are totally
	wrong.  The configuration file you actually need is:

		server.modules += ( "mod_scgi" )

		#scgi.debug = 10
		scgi.server = (
		    "/gdp/v1/" =>
			( "gdp" =>
			    ( "host"  => "127.0.0.1",
			      "port" => 8001,
			      "check-local" => "disable",
			    )
			)
		    )

	(Normally in /usr/local/etc/lighttpd/conf.c/scgi.conf) This will
	tell lighttpd to connect to an SCGI server on the local machine,
	port 8001.  You'll also need to make sure the line
	"include conf.d/scgi.conf" in /usr/local/etc/lighttpd/modules.conf
	is not commented out.  The rest of the lighttpd setup should be
	off the shelf.  I've set up instance of lighttpd to listen on
	port 8080 instead of the default port 80, and the rest of these
	instructions will reflect that.

   3.	Start up the GDP RESTful interface server in apps/gdp-rest.
	It will run in foreground and spit out some debugging
	information.  For even more, use -D\*=20 on the command
	line.  This sets all debug flags to level 20.  The backslash
	is just to keep the Unix shell from trying to glob the
	asterisk.

   4.	Start the lighttpd server, for example using:
	"lighttpd -f /usr/local/etc/lighttpd/lighttpd.conf -D".
	This assumes that your configuration is in
	/usr/local/etc/lighttpd.  The -D says to run in foreground
	and you can skip it if you want.  You may want to turn on
	some debugging inside the daemon to help you understand the
	interactions.  See .../etc/lighttpd/conf.d/debug.conf.

   5.	The actual URIs and methods used by the REST interface are
	described in doc/gdp-rest-interface.html.  See that for
	details.

	You can do GETs from inside a browser such as Firefox or
	Chrome, but not POSTs.  To use other methods you'll have to
	use Chrome.  Install the "postman" extension to enable
	sending of arbitrary methods such as POST and PUT.

Full List of Administrative Parameters:
	swarm.gdp.routers --- the address(es) of the gdp routing layer
		(used by clients).  Multiple addresses can be included,
		separated by semicolons.  If no port is included, it
		defaults to 8007.  This will eventually be replaced by
		service discovery.  Defaults to 127.0.0.1:8007.
	swarm.gdp.event.loopdelay --- if the event loop exits for some
		reason, this is the number of microseconds to delay
		before restarting the loop.  Defaults to 100000 (100msec).
	swarm.gdp.event.looptimeout --- the timeout for the event loop;
		this is mostly just to make sure things don't "hang up"
		forever.  Defaults to 30 (seconds).
	swarm.gdp.connect.timeout --- how long to wait for a connection
		to the GDP routing layer before giving up and trying
		another entry point (in milliseconds).  Defaults to
		10000 (ten seconds).
	swarm.gdp.reconnect.delay --- the number of milliseconds to wait
		before attempting to reconnect if the routing layer is
		disconnected.  Defaults to 100 milliseconds.
	swarm.gdp.invoke.timeout --- the number of milliseconds to wait
		for a response before timing out a GDP request.  Defaults
		to 10000 (ten seconds).
	swarm.gdp.invoke.retries --- the number of times to re-send a
		request when no response is received.  Defaults to 3
		(meaning that the request may be sent up to 4 times
		total).
	swarm.gdp.log.facility --- the name of the log facility to use
		(see syslog(3) for details).  The "gdp" in the name
		can be replaced by an individual program name to set a
		value that applies only to that program, e.g.,
		"swarm.gdplogd.log.facility".  If both are set, the more
		specific name wins.  Defaults to "local4".
	swarm.gdplogd.gcl.dir --- the directory in which log data will
		be stored.  Defaults to "/var/swarm/gcls".
	swarm.gdplogd.reclaim.interval --- how often to wake up to
		reclaim unused resources.  Defaults to 15 (seconds).
	swarm.gdplogd.gcl.reclaim-age --- how long a GCL is permitted to
		sit idle before its resources are reclaimed.  Defaults
		to 300 (seconds, i.e., five minutes).
	swarm.gdplogd.gdpname --- the name to use as the source address
		for protocol initiating from this program.  If not set,
		a random name is made up when the program is started.
		Generally speaking, you will want to set this parameter;
		I recommend reverse-dns addresses, e.g.,
		swarm.gdplogd.gdpname=edu.berkeley.eecs.gdp-01.gdplogd.
	swarm.rest.kv.gclname --- the name of the GCL to use for the
		key-value store.  Defaults to "swarm.rest.kv.gcl".
	swarm.rest.prefix --- the REST prefix (e.g., /gdp/v1/).
	swarm.rest.scgi.port --- the port number for the SCGI server to
		listen on.  If you change this you'll also have to
		change the lighttpd configuration.  Defaults to 8001.
	swarm.rest.scgi.pollinterval --- how often to poll for SCGI
		connections (in microseconds).  Defaults to 100000
		(100 msec).
	libep.time.accuracy --- the value filled in for the "accuracy"
		field in time structures (defaults to zero).
	libep.thr.pool.min_workers --- the default minimum number of
		worker threads in the thread pool.  If not specified
		the default is 1.  It can be overridden by the calling
		application.
	libep.thr.pool.max_workers --- the default maximum number of
		worker threads in the thread pool.  If not specified
		the default is two times the number of available
		cores.  It can be overridden by the calling application.

Setting Debug Flags:
	You can turn on debugging output using a command line flag,
	conventionally "-D<pattern>=<level>".  The <pattern> specifies
	which flags should be set and <level> specifies how much
	should be printed; zero indicates no output, and more output
	is added as the values increase.

	By convention <level> is no greater than 127, and values 100
	and above may modify the base behavior of the program (i.e.,
	do more than just printing information).

	Each debug flag has a hierarchical name with (by convention)
	"." as the separator, for example, "gdp.proto" to indicate
	the protocol processing of the GDP.  The "what(1)" program on
	a binary will show you which debug flags are available
	including a short description.

Directory Structure:
	ep --- A library of C utility functions.  This is a stripped
		down version of a library I wrote several years ago.
		If you look at the code you'll see vestiges of some
		of the stripped out functions.  I plan on cleaning
		this version up and releasing it again.
	gdp --- A library for GDP manipulation.  This is the library
		that applications must link to access the GDP.
	gdplogd --- The GDP log daemon.  This implements physical
		(on disk) logs for the GDP.  The implementation is
		still fairly simplistic.  It depends on a routing
		layer (currently gdp_router, in a separate repository).
	scgilib --- An updated version of the SCGI code from
		http://www.xamuel.com/scgilib/.  SCGI permits a
		web server to access outside programs by opening
		a socket in a manner much more efficient than basic
		CGI fork/exec.  This is only used for the REST interface.
	apps --- Application programs, including tests.
	doc --- Some documentation, woefully incomplete.
	examples --- Some example programs, intended be usable as
		tutorials.
	lang --- sub-directories with language-specific application
                programs and supporting code.
        lang/js --- JavaScript-specific apps and libraries.  Also contains
                the Node.js/JS GDP RESTful interface code.  See associated
                README files for details.
        lang/python --- Python-specific apps and libraries.
