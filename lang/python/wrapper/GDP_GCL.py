#!/usr/bin/python

from MISC import *
from GCL_NAME import *
from GDP_DATUM import *

class GDP_GCL:
    """
    A class that represents a GCL handle. A GCL handle resembles an open
        file handle in various ways. However, it is still different in 
        certain ways
    """    

    # We need to keep a list of all the open GCL handles we have, and 
    #   their associated gdp handles. I don't see any cleaner solution
    #   to how to differentiate between events associated for different 
    #   GCLs. Also, we no longer can free the handles automatically.
    #   Why? How would python know that we are not planning to get an
    #   event for a gcl handle?


    # C pointer to python object mapping
    object_dir = {}

    class gdp_gcl_t(Structure):
        "Corresponds to gdp_gcl_t structure exported by C library"
        pass

    class gdp_event_t(Structure):
        "Corresponds to gdp_event_t structure exported by C library"
        pass

    def __init__(self, **kwargs):
        """
        Can be called in two modes:
        1) create=True, name=<name-of-gcl>
        2) open=True, name=<name-of-gcl>, iomode=<mode>

        In both cases, the name is a GCL_NAME object, which could be None (in
            which case, a random name is generated by the C library)
        mode is one of the following: GDP_MODE_ANY, GDP_MODE_RO, GDP_MODE_AO
        """

        # self.ptr is just a C style pointer, that we will assign to something
        self.ptr = POINTER(self.gdp_gcl_t)()

        name = kwargs.get("name", None)

        if name is not None:
            # FIXME: Clean this mess up. How to handle the single case when a new GCL
            #           is created without any name specified is messing this up totally.
            
            # in any case, we do need an internal represenation of the name.
            gcl_name_python = name.internal_name()
            # convert this to a string that ctypes understands. Some ctypes magic ahead
            buf = create_string_buffer(gcl_name_python,32)
            gcl_name_ctypes_ptr = cast(byref(buf), POINTER(GCL_NAME.name_t))
            gcl_name_ctypes = gcl_name_ctypes_ptr.contents
 

        if kwargs.get("create", False)==True:
            # create a new gcl
            __func = gdp.gdp_gcl_create

            __name = None
            if name==None:
                __func.argtypes = [c_void_p, POINTER(POINTER(self.gdp_gcl_t))]
            else:
                __name = gcl_name_ctypes
                __func.argtypes = [GCL_NAME.name_t, POINTER(POINTER(self.gdp_gcl_t))]

            __func.restype = EP_STAT
            estat = __func(__name, byref(self.ptr))
            check_EP_STAT(estat)


        elif kwargs.get("open", False)==True:
            # open an existing gcl

            __func = gdp.gdp_gcl_open
            __func.argtypes = [GCL_NAME.name_t, c_int, POINTER(POINTER(self.gdp_gcl_t))]
            __func.restype = EP_STAT

            estat = __func(gcl_name_ctypes, kwargs["iomode"], pointer(self.ptr))
            check_EP_STAT(estat)

        else:
            # FIXME: handle this more gracefully
            raise Exception

        # Also add itself to the global list of objects
        # XXX: See if there is a cleaner way of dealing with this?
        self.object_dir[addressof(self.ptr.contents)] = self


    def __del__(self):
        "close this GCL handle, and free the allocated resources"

        if bool(self.ptr)==False:   # null pointers have a false boolean value
            # Null pointer => no memory allocated => nothing to clean up
            #   this happens if __init__ did not finish
            return


        # remove the entry from object directory
        self.object_dir.pop(addressof(self.ptr.contents), None)

        # call the C function to free associated C memory block
        __func = gdp.gdp_gcl_close
        __func.argtypes = [POINTER(self.gdp_gcl_t)]
        __func.restype = EP_STAT

        estat = __func(self.ptr)
        check_EP_STAT(estat)
        return 
 
     
    def read(self, recno):
        """
        Returns a datum dictionary. The dictionary has the following keys:
            - recno: the record number for this GDP
            - ts   : the timestamp, which itself is a dictionary with the keys
                        being tv_sec, tv_nsec, tv_accuracy
            - data : the actual data associated with this datum. 
        """

        datum = GDP_DATUM()
        __recno = gdp_recno_t(recno)

        __func = gdp.gdp_gcl_read
        __func.argtypes = [POINTER(self.gdp_gcl_t), gdp_recno_t, POINTER(GDP_DATUM.gdp_datum_t)]
        __func.restype = EP_STAT

        estat = __func(self.ptr, __recno, datum.gdp_datum)
        check_EP_STAT(estat)

        datum_dict = {}
        datum_dict["recno"] = datum.getrecno()
        datum_dict["ts"] = datum.getts()
        datum_dict["data"] = datum.getbuf()
   
        return datum_dict 
    

    def publish(self, datum_dict):
        """
        Write a datum to the GCL. The datum should be a dictionary, with the following
            possible keys:
            - recno: record number
            - ts   : timestamp (another dictionary that has tv_sec, tv_nsec, tv_accuracy)
            - data : the actual data that is to be written
        (The behaviour for a datum with a specified recno and/or ts is the same as with the 
            C library)
        """

        datum = GDP_DATUM()

        if "recno" in datum_dict.keys(): datum.setrecno(datum_dict["recno"])
        if "ts" in datum_dict.keys(): datum.setts(datum_dict["ts"])
        if "data" in datum_dict.keys(): datum.setbuf(datum_dict["data"])

        __func = gdp.gdp_gcl_publish
        __func.argtypes = [POINTER(self.gdp_gcl_t), POINTER(GDP_DATUM.gdp_datum_t)]
        __func.restype = EP_STAT

        estat = __func(self.ptr, datum.gdp_datum)
        check_EP_STAT(estat)

        return 

    # XXX: Check if this works. 
    # More details here: http://python.net/crew/theller/ctypes/tutorial.html#callback-functions
    # The first argument, I believe, is the return type, which I think is void*
    gdp_gcl_sub_cbfunc_t = CFUNCTYPE(c_void_p, POINTER(gdp_gcl_t), 
                                POINTER(GDP_DATUM.gdp_datum_t), c_void_p)

    
    def subscribe(self, start, numrecs, timeout, cbfunc, cbarg):
        """
        This works somewhat similar to the subscribe in GDP C api.
            Callback is not fully implemented yet. For now, timeout, 
                cbfunc, cbarg are ignored
        """


        # casting start to ctypes
        __start = gdp_recno_t(start)

        # casting numrecs to ctypes
        __numrecs = c_int32(numrecs)

        # we get timeout as a dictionary, that we then translate to a C structure
        class __EP_TIME_SPEC(Structure):
            pass

        __EP_TIME_SPEC._fields_ = [ ("tv_sec", c_int64),
                                    ("tv_nsec", c_uint32),
                                    ("tv_accuracy", c_float)]

        # if timeout is None, then we just skip this
        if timeout == None:
            __timeout = None
        else:
            __timeout = __EP_TIME_SPEC()
            __timeout.tv_sec = c_int64(timeout['tv_sec'])
            __timeout.tv_nsec = c_uint32(timeout['tv_nsec'])
            __timeout.tv_accuracy = c_float(timeout['tv_accuracy'])
    

        # casting the python function to the callback function
        if cbfunc==None:
            __cbfunc = None
        else:
            __cbfunc = self.gdp_gcl_sub_cbfunc_t(cbfunc)

   
        __func = gdp.gdp_gcl_subscribe
        if cbfunc==None:
            __func.argtypes = [POINTER(self.gdp_gcl_t), gdp_recno_t, c_int32, POINTER(__EP_TIME_SPEC), 
                                c_void_p, c_void_p]
        else:
            __func.argtypes = [POINTER(self.gdp_gcl_t), gdp_recno_t, c_int32, POINTER(__EP_TIME_SPEC), 
                                self.gdp_gcl_sub_cbfunc_t, c_void_p]

        __func.restype = EP_STAT
 
        estat = __func(self.ptr, __start, __numrecs, __timeout, __cbfunc, cbarg)
        check_EP_STAT(estat)
        return estat
        

    def multiread(self, start, numrecs, cbfunc, cbarg):
        """
        similar to multiread in the GDP C API
            Callback is not fully implemented yet. For now, 
                cbfunc, cbarg are ignored
        """


        # casting start to ctypes
        __start = gdp_recno_t(start)

        # casting numrecs to ctypes
        __numrecs = c_int32(numrecs)

        # casting the python function to the callback function
        if cbfunc==None:
            __cbfunc = None
        else:
            __cbfunc = self.gdp_gcl_sub_cbfunc_t(cbfunc)

        __func = gdp.gdp_gcl_multiread
        if cbfunc==None:
            __func.argtypes = [POINTER(self.gdp_gcl_t), gdp_recno_t, c_int32,
                                c_void_p, c_void_p]
        else:
            __func.argtypes = [POINTER(self.gdp_gcl_t), gdp_recno_t, c_int32,
                                self.gdp_gcl_sub_cbfunc_t, c_void_p]
        __func.restype = EP_STAT
 
        estat = __func(self.ptr, __start, __numrecs, __cbfunc, cbarg)
        check_EP_STAT(estat)
        return estat
        

    
    def print_to_file(self, fh, detail, indent):
        """
        Print this GDP object to a file. Could be sys.stdout
            The actual printing is done by the C library
        """
 
        __fh = PyFile_AsFile(fh)
    
        __func = gdp.gdp_gcl_print
        __func.argtypes = [POINTER(self.gdp_gcl_t), FILE_P, c_int, c_int]
        # ignore the return type
    
        __func(self.ptr, __fh, c_int(detail), c_int(indent))
        return
    

   
    def getname(self):
        "Get the name of this GCL, returns a GCL_NAME object"
     
        __func = gdp.gdp_gcl_getname
        __func.argtypes = [POINTER(self.gdp_gcl_t)]
        __func.restype = POINTER(GCL_NAME.name_t)
    
        gcl_name_pointer = __func(self.ptr)
        gcl_name = string_at(gcl_name_pointer,32)
        return GCL_NAME(gcl_name)


    @classmethod
    def get_next_event(cls,wait):
        """
        Get the events for any open GCL. If wait is True, and there is no 
            event, then blocks. If wait is False, and there is no event, 
            returns None
        """

        __func1 = gdp.gdp_event_next
        __func1.argtypes = [c_bool]
        __func1.restype = POINTER(cls.gdp_event_t)

        event_ptr = __func1(wait)        
        if bool(event_ptr)==False: # Null pointers have a false boolean value
            return None
        
        # now get the associated GCL handle
        __func2 = gdp.gdp_event_getgcl
        __func2.argtypes = [POINTER(cls.gdp_event_t)]
        __func2.restype = POINTER(cls.gdp_gcl_t) 

        gcl_ptr = __func2(event_ptr)

        # now find this in the dictionary
        gcl_handle = cls.object_dir.get(addressof(gcl_ptr.contents), None)

        # also get the associated datum object
        __func3 = gdp.gdp_event_getdatum
        __func3.argtypes = [POINTER(cls.gdp_event_t)]
        __func3.restype = POINTER(GDP_DATUM.gdp_datum_t)

        datum_ptr = __func3(event_ptr)
        print datum_ptr
        datum =  GDP_DATUM(ptr=datum_ptr)
        datum_dict = {}
        datum_dict["recno"] = datum.getrecno()
        datum_dict["ts"] = datum.getts()
        datum_dict["data"] = datum.getbuf()


        # find the type of the event
        __func4 = gdp.gdp_event_gettype 
        __func4.argtypes = [POINTER(cls.gdp_event_t)]
        __func4.restype = c_int

        event_type = __func4(event_ptr)

        # also free the event 
        __func5 = gdp.gdp_event_free
        __func5.argtypes =[POINTER(cls.gdp_event_t)]
        __func5.restype = EP_STAT

        estat = __func5(event_ptr)
        check_EP_STAT(estat)

        gdp_event = {}
        gdp_event["gcl_handle"] = gcl_handle
        gdp_event["datum"] = datum_dict
        gdp_event["type"] = event_type


        return gdp_event

