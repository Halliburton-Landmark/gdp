<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>GDP Library Implementation</title>
  </head>
  <body>
    <h1>Global Data Plane Library Implementation</h1>
    2014-10-04<br>
    <p>This document describes the internals of the Global Data Plane
      (GDP) run-time library at a conceptual level.&nbsp; This library
      is linked into any client that wishes to participate in the Global
      Data Plane.&nbsp; The base library is implemented in C, which is
      what this document will assume, but bindings for the external
      interfaces are available for other languages.&nbsp; See the
      document Global Data Plane Programmatic API for details of that
      interface.<br>
    </p>
    <h2>Overview</h2>
    <p>To be completed.<br>
      Main modules:<br>
    </p>
    <ul>
      <li>API.</li>
      <li>Packet assembly/disassembly.</li>
      <li>Datum management.<br>
      </li>
      <li>I/O buffering.</li>
      <li>GCL associative cache.</li>
      <li>GDP protocol.</li>
      <li>Request management.</li>
      <li>Event loop.</li>
    </ul>
    <p>Generally speaking, the GDP library is structured as an
      event-driven program with a synchronous API.&nbsp; One thread
      services events (e.g., responses from the GDP daemon) while the
      main thread executes the user application.&nbsp; When the
      application needs to contact the daemon, it sends the message and
      then waits on a condition variable until signaled.&nbsp; In the
      meantime, the event look will wait for a response, associate it
      with the appropriate GCL handle on the basis of the GCL
      associative cache, and then signal the application to collect the
      results.<br>
    </p>
    <p>Data is exchanged through a data structure of type gdp_datum_t,
      which contains a record number a time stamp, and a data
      buffer.&nbsp; When sending data to the GDP daemon, the application
      creates a datum, fills it in with data, and sends it to the
      daemon.&nbsp; When receiving data from the GDP daemon, the
      application passes a datum into the GDP library that will be
      filled in.&nbsp; Generally when sending data to the daemon the
      record number and time stamp are ignored and replaced with the
      real record number and timestamp after the write completes.<br>
    </p>
    <h2>Module Details</h2>
    <h3>API</h3>
    <p>The API module (gdp_api.c) defines all the externally visible
      routines.&nbsp; Since these are already documented in the GDP
      Programmatic API document, suffice it to say that it does the
      "translation" between the internal protocol and the external API.<br>
    </p>
    <h3>Request Management</h3>
    <p>Implemented in gdp_req.c.<br>
    </p>
    <p>Internally the data flow is managed through a series of
      requests.&nbsp; In many cases there will be only one request
      active on a given GCL at a time, but this is not necessarily true,
      especially in the GDP daemon when handling subscriptions (each
      subscription is a separate request).&nbsp; Requests (potentially)
      have a pointer to a GCL handle, a pointer to a data packet (in
      internal form), the status code from the operation embodied in the
      request, and special information for use when processing
      subscriptions.<br>
    </p>
    <p>The internal routines are:<br>
    </p>
    <table width="100%" border="1" cellpadding="2" cellspacing="2">
      <tbody>
        <tr>
          <td valign="top">_gdp_req_new<br>
          </td>
          <td valign="top">Create a new request and fill it in with a
            GDP protocol command, GCL handle, I/O channel, and flags
            (passed in as parameters) as well as space for a packet (in
            internal form) and request ID.<br>
          </td>
        </tr>
        <tr>
          <td valign="top">_gdp_req_free<br>
          </td>
          <td valign="top">Free the request and all associated resources
            such as the space for packet information.&nbsp; It also
            decrements the reference count on the GCL handle indicated
            in the request.<br>
          </td>
        </tr>
        <tr>
          <td valign="top">_gdp_req_freeall<br>
          </td>
          <td valign="top">Free all requests associated with a
            particular GCL handle.&nbsp; GCLs that have pending
            subscriptions will have one request per subscription, which
            are linked off the GCL handle.<br>
          </td>
        </tr>
        <tr>
          <td valign="top">_gdp_req_find<br>
          </td>
          <td valign="top">Given a GCL handle and a request ID, find the
            associated request on the list associated with that GCL
            handle.&nbsp; Note that request IDs need only be unique
            within a particular GCL handle.<br>
          </td>
        </tr>
      </tbody>
    </table>
    <p><br>
    </p>
    <h3>Datums</h3>
    <p>Implemented in gdp_datum.c.<br>
    </p>
    <p>As described above, a datum is the internal version of a GCL
      record.&nbsp; The routines, which are externally visible, are:<br>
    </p>
    <table width="100%" border="1" cellpadding="2" cellspacing="2">
      <tbody>
        <tr>
          <td valign="top">gdp_datum_new<br>
          </td>
          <td valign="top">Create a new empty datum, including its
            associated (empty) buffer.<br>
          </td>
        </tr>
        <tr>
          <td valign="top">gdp_datum_free<br>
          </td>
          <td valign="top">Free the datum, including it's associated
            data buffer.<br>
          </td>
        </tr>
        <tr>
          <td valign="top">gdp_datum_getrecno<br>
          </td>
          <td valign="top">Get the record number.<br>
          </td>
        </tr>
        <tr>
          <td valign="top">gdp_datum_setrecno<br>
          </td>
          <td valign="top">Set the record number.<br>
          </td>
        </tr>
        <tr>
          <td valign="top">gdp_datum_getts<br>
          </td>
          <td valign="top">Get the timestamp.<br>
          </td>
        </tr>
        <tr>
          <td valign="top">gdp_datum_setts<br>
          </td>
          <td valign="top">Set the timestamp.<br>
          </td>
        </tr>
        <tr>
          <td valign="top">gdp_datum_getdlen<br>
          </td>
          <td valign="top">Get the length of the data buffer.<br>
          </td>
        </tr>
        <tr>
          <td valign="top">gdp_datum_getbuf<br>
          </td>
          <td valign="top">Get the data buffer itself.<br>
          </td>
        </tr>
        <tr>
          <td valign="top">gdp_datum_print<br>
          </td>
          <td valign="top">Print a datum in a format suitable for
            debugging use.<br>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <h3>GCL Associative Cache</h3>
    <p>Implemented in gdp_gcl.c.<br>
    </p>
    <p>The primary purpose of the GCL Associative Cache is to allow
      quick association between a GCL name and the associated
      handle.&nbsp; When a packet is received that contains a GCL name,
      this delivers the handle that contains the necessary state
      information.<br>
    </p>
    <table width="100%" border="1" cellpadding="2" cellspacing="2">
      <tbody>
        <tr>
          <td valign="top">_gdp_gcl_cache_init<br>
          </td>
          <td valign="top">Initializes the GCL cache.&nbsp; Called only
            once on startup.<br>
          </td>
        </tr>
        <tr>
          <td valign="top">_gdp_gcl_cache_get<br>
          </td>
          <td valign="top">Extracts the GCL handle from the cache based
            on name and I/O mode.&nbsp; If it is found the reference
            count on the GCL handle is incremented; if not, it returns
            NULL.<br>
          </td>
        </tr>
        <tr>
          <td valign="top">_gdp_gcl_cache_add<br>
          </td>
          <td valign="top">Adds the GCL handle to the cache.<br>
          </td>
        </tr>
        <tr>
          <td valign="top">_gdp_gcl_cache_drop<br>
          </td>
          <td valign="top">Removes the GCL name → handle association
            from the cache.<br>
          </td>
        </tr>
        <tr>
          <td valign="top">_gdp_gcl_incref<br>
          </td>
          <td valign="top">Increments the reference count on the GCL
            handle.<br>
          </td>
        </tr>
        <tr>
          <td valign="top">_gdp_gcl_decref<br>
          </td>
          <td valign="top">Decrements the reference count on the GCL
            handle.&nbsp; If the reference count reaches zero the handle
            becomes a candidate for cleanup, but this is deferred
            because, in the common case, another request for this GCL
            will appear shortly.<br>
          </td>
        </tr>
        <tr>
          <td valign="top">_gdp_gcl_newhandle<br>
          </td>
          <td valign="top">Creates a new GCL handle.&nbsp; Note that
            this is just the library data — it sends no protocol to the
            GDP daemon.<br>
          </td>
        </tr>
        <tr>
          <td valign="top">_gdp_gcl_freehandle<br>
          </td>
          <td valign="top">Does the actual deallocation of the
            handle.&nbsp; If the GCL includes a free function, that
            function is called (this is used by the GDP daemon).<br>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <h3>Packets</h3>
    Implemented in gdp_pkt.c.<br>
    <br>
    Packets are marshalled and demarshalled in gdp_pkt.c.&nbsp; Each
    packet has the following fields (with the number of octets for the
    field):<br>
    <ul>
      <li>Protocol version (1).</li>
      <li>Command or Ack/Nak (1).</li>
      <li>Flags (1).&nbsp; These indicate the presence of the optional
        fields.</li>
      <li>Reserved for future use (must be zero when sending, ignored on
        receive) (1).</li>
      <li>Length of data portion (4).</li>
      <li>Request ID (4, optional).</li>
      <li>GCL name (32, optional).</li>
      <li>Record number (8, optional).</li>
      <li>Commit timestamp (16, optional).</li>
      <li>Data (as indicated by the length field).<br>
      </li>
    </ul>
    <p>One field is used to indicate both commands and
      acknowledgements/negative acknowledgements.&nbsp; See the comments
      in gdp_pkt.h for the details of those values.<br>
    </p>
    <p>The routines for handling packets are:</p>
    <table width="100%" border="1" cellpadding="2" cellspacing="2">
      <tbody>
        <tr>
          <td valign="top">_gdp_pkt_new<br>
          </td>
          <td valign="top">Allocates a new (empty) packet.<br>
          </td>
        </tr>
        <tr>
          <td valign="top">_gdp_pkt_free<br>
          </td>
          <td valign="top">Frees a packet.<br>
          </td>
        </tr>
        <tr>
          <td valign="top">_gdp_pkt_out<br>
          </td>
          <td valign="top">Given a packet structure and an output
            buffer, converts that packet to external format and writes
            it to the buffer.&nbsp; Under normal circumstances this
            buffer is associated with an I/O channel, and hence is
            written to the communication socket automatically.<br>
          </td>
        </tr>
        <tr>
          <td valign="top">_gdp_pkt_in<br>
          </td>
          <td valign="top">Reads a packet from an I/O buffer and
            converts it to internal format.&nbsp; It is possible that
            this routine can return without reading the entire packet
            with the special status code GDP_STAT_KEEP_READING.&nbsp;
            Under most cases it should be called in a loop until a
            successful status is returned.&nbsp; As with _gdp_pkt_out,
            the I/O buffer is normally associated with an I/O
            channel.&nbsp; See the discussion of the event loop for more
            details.<br>
          </td>
        </tr>
        <tr>
          <td valign="top">_gdp_pkg_dump<br>
          </td>
          <td valign="top">Prints a packet in a form suitable only for
            debugging.<br>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <h3>GDP Protocol</h3>
    <p>Implemented in gdp_proto.c.<br>
    </p>
    <h3>Event Loop</h3>
  </body>
</html>
