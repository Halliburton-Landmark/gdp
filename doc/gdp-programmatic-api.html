<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <meta content="text/html; charset=windows-1252"
      http-equiv="content-type">
    <title>Global Data Plane Programmatic API</title>
  </head>
  <body>
    <h1>Global Data Plane Programmatic API Proposal</h1>
    <h4>Editor: Eric Allman, U.C. Berkeley Swarm Lab,
      eric@cs.berkeley.edu</h4>
    <h5>Version 0.6, 2014-09-08</h5>
    <br>
    <p> This is a strawman proposal. It is not complete. Note that this
      does not include the in-system representation except where that
      impacts the API, nor does it discuss discovery at this time. It is
      only about a C-level API (in particular, not about a
      network-protocol level; Ben Zhang and Chang Lan have a proposal
      for that level). We'll need bindings for languages such as C++ and
      Python; I've tried to keep this proposal reasonably consistent
      with that requirement.</p>
    <p> How does AVB fit into this? Need to provide resource
      requirements on creation to be sure. What about opening?</p>
    <p> This is based in part on Palmer Dabbelt's papers "Swarm OS
      Universal Dataplane" [Dab13a] and "What is the Universal
      Dataplane, Anyway?" [Dab13b]. He had two slightly different
      interfaces in those two papers, the first using read, write.
      watch, provide, and request and the second using publish,
      subscribe, request, and provide. Palmer's interface request(query,
      qos, cost) requests access to an “aardvark” (now called a GDP
      Channel-Log or GCL) that matches the given query given that
      another service can provide the at least requested QoS for at most
      the requested cost; provide(name, qos, cost) asserts that this
      service is capable of providing access to the named aardvark under
      the constraints of the given qos and for the provided cost.</p>
    <p> Note: there is code implementing most of this proposal. It only
      operates on a single machine and isn't particularly fast.</p>
    <br>
    <h2> 1 Theory of Operation</h2>
    <p> GDP-based applications rely on two pieces: an in-process GDP
      library and a GDP Daemon. The GDP Daemon does most of the heavy
      lifting; it will be described in a different document.</p>
    <p> The primary point of the GDP library is to speak the network
      protocol between the API and the GDP Daemon. The library is
      threaded, with (at the moment) two threads: one to process events
      (data arriving from the daemon, although others can be added), and
      the other to run the application itself. This allows the
      application to pretend it is a sequential program while still
      allowing asynchronous input from the GDP Daemon (e.g., processing
      results from subscription requests).</p>
    <p> The primary abstraction is the GDP Channel-Log (GCL). A GCL
      represents the rendezvous point for communication in the data
      plane. It is not directly tied to either a file or a network
      connection. On creation, a GCL is assigned a name, which is just a
      random UUID [maybe; see discussion]. A GCL is append-only to
      writers (true or false?). Palmer called this an aardvark, for lack
      of a better name.</p>
    <p style="font-style: italic;"> [[Really need more here.]]</p>
    <p> For the moment you can access the dataplane in one of two modes:
      synchronous mode (using <code>gdp_gcl_read</code> for reading) an
      asynchronous mode (using <code>gdp_gcl_subscribe</code> for
      reading). To use it in asynchronous mode you must subscribe to any
      GCLs of interest and then call <code>gdp_event_next</code>
      repeatedly to read the results.&nbsp; These are described in more
      detail below.<br>
    </p>
    <p>Before the GDP library can be used it must be initialized:<br>
    </p>
    <h3> </h3>
    <hr size="2" width="100%">
    <h4> Name</h4>
    gdp_init — Initialize the GDP library<br>
    <h4> Synopsis</h4>
    <pre>EP_STAT gdp_init(void)
</pre>
    <h4> Notes</h4>
    <ul>
      <li> Initializes the GDP library.&nbsp; <em><strong>Must</strong></em>
        be called before any other GDP functions are invoked.<br>
      </li>
    </ul>
    <hr size="2" width="100%"><br>
    <h2>2&nbsp; GCL Synchronous Operation</h2>
    <p>Synchronous operations block until the operation is complete.<br>
    </p>
    <hr size="2" width="100%">
    <h4> Name</h4>
    gdp_gcl_create — Create an append-only GCL<br>
    <h4> Synopsis</h4>
    <pre>EP_STAT gdp_gcl_create(gcl_name_t gcl_name,
		gdp_gcl_t **gclhandlep)
</pre>
    <h4> Notes</h4>
    <ul>
      <li> Creates a GCL with the given name, which must be a 256-bit
        value (e.g., the hash of a human-meaningful string).</li>
      <li> Returns a GCL handle.</li>
      <li> The gclhandle is writable (but can it be readable?)</li>
      <li> We probably need payment information, some way of specifying
        resource requirements, and so forth.</li>
      <li> Palmer did not describe anything that explicitly creates a
        GCL. I think explicit creation is important, but the semantics
        could be automatic creation on first reference.</li>
    </ul>
    <br>
    <hr size="2" width="100%">
    <h4> Name</h4>
    gdp_gcl_open — Open an existing GCL<br>
    <h4> Synopsis</h4>
    <pre>EP_STAT gdp_gcl_open(gcl_name_t name,
		gcl_iomode_t rw,
		gdp_gcl_t **gclhandle)
</pre>
    <h4> Notes</h4>
    <ul>
      <li> Pass in type/subtype? That would make it seem to be part of
        the naming. Alternatively there could be a "requirements"
        parameter that would specify this information as well as QoS
        requirements. This could be useful.</li>
      <li> Can handles be R/W or are the only options RO or AO (Append
        Only)? Or for that matter can you update an existing GCL
        (overwrite) by cloning a new version (e.g., using CoW)?</li>
      <li> Do we have to pass in a permission token? This could be a
        key. If GCLes are named by their public key then this will be
        implicit, but if ACLs are used then the identity (more likely
        some proxy for the identity) will have to be passed in. Some
        applications might even want to have multiple identities based
        on their roles.</li>
      <li> It may be useful to pass in a "payment" parameter. See
        discussion below.</li>
      <li> Perhaps qos should be replaced by a descriptor parameter a la
        gdp_gcl_create.</li>
    </ul>
    <hr size="2" width="100%">
    <h4> </h4>
    <h4> Name</h4>
    gdp_gcl_close — Close a GCL<br>
    <h4> Synopsis</h4>
    <pre>EP_STAT gdp_gcl_close(gdp_gcl_t *gclhandle)
</pre>
    <h4> Notes</h4>
    <ul>
      <li> Should this interface say whether to preserve or drop the GCL
        (i.e., is it persistent, or for how long)?</li>
    </ul>
    <br>
    <hr size="2" width="100%">
    <h4> Name</h4>
    gdp_gcl_getname — Return the name of a GCL<br>
    <h4> Synopsis</h4>
    <pre>EP_STAT gdp_gcl_getname(gdp_gcl_t *gclhandle,
		gcl_name_t namebuf)
</pre>
    <h4> Notes</h4>
    <ul>
      <li> Returns the name of the GCL referenced by gclhandle into
        namebuf. Assumes that names are a fixed size, otherwise will
        need a buffer length.</li>
      <li> May not be necessary if the creator provides the name; really
        only intended after gdp_gcl_create so that the name can be
        shared to other nodes that want to gdp_gcl_open it.</li>
    </ul>
    <br>
    <hr size="2" width="100%">
    <h4> Name</h4>
    gdp_gcl_getstat — Return information about a GCL <b>[NOT YET
      IMPLEMENTED]</b><br>
    <h4> Synopsis</h4>
    <pre>EP_STAT gdp_gcl_getstat(gdp_gcl_t *gclhandle,
		gcl_stat_t *statbuf)
</pre>
    <h4> Notes</h4>
    <ul>
      <li> What status is included? Size (or number of
        records/messages), type, subtype, last access, …</li>
      <li> What about type-dependent status information?</li>
      <li> Should this take a handle or a name? Or two interfaces?</li>
    </ul>
    <br>
    <hr size="2" width="100%">
    <h4> Name</h4>
    gdp_gcl_print — print a GCL handle (for debugging)<br>
    <h4>Synopsis</h4>
    <pre>void gdp_gcl_print(const gdp_gcl_t *gclh, FILE *fp)</pre>
    <h4>Notes</h4>
    <ul>
      <li>Prints the GCL on the indicated file.</li>
      <li>The output will contain internal information; it is not
        intended to display information to end users.<br>
      </li>
    </ul>
    <hr size="2" width="100%">
    <h4> Name</h4>
    gdp_gcl_publish — Publish (append) a record to a writable GCL<br>
    <h4> Synopsis</h4>
    <pre>EP_STAT gdp_gcl_publish(gdp_gcl_t *gclhandle,
		gdp_datum_t *datum)
</pre>
    <h4> Notes</h4>
    <ul>
      <li> Appends the indicated datum to the GCL.</li>
      <li>Any subscribers get immediate updates about this publication.</li>
      <li><i>Does this return before the data is actually committed or
          after? If before it may be hard to correlate errors to
          appends. If after there will probably be performance issues.</i></li>
      <li><i> Should writes be asynchronous at this level? Could pass in
          a message id which can be returned in something like a
          gdp_gcl_sync() call. Easy to build synchronous on top of
          asynchronous.</i></li>
      <li><i> Corresponds to Palmer's write [Dab13a] and publish(name,
          message) [Dab13b], where name is the name of the GCL and
          message is the data.</i></li>
      <li><i> Messages written into a GCL become available to
          gdp_gcl_read and to functions registered with
          gdp_gcl_subscribe.</i></li>
      <li><i> This definition assumes an octet-stream-based interface.
          If a message-based interface is chosen then this obviously
          changes. The correct abstraction under those assumptions
          probably passes in a message, which is a structure including
          time and location information as well as the data itself. See
          the discussion in the next section.</i></li>
    </ul>
    <br>
    <hr size="2" width="100%">
    <h4> Name</h4>
    gdp_gcl_read — Read from a readable GCL<br>
    <h4> Synopsis</h4>
    <pre>EP_STAT gdp_gcl_read(gdp_gcl_t *gclhandle,
		gdp_recno_t recno,
		gdp_datum_t *datum)
</pre>
    <h4> Notes</h4>
    <ul>
      <li> Reads the specified record number and returns it in the
        user-supplied datum (see below).</li>
      <li>Assumes a message-oriented interface. It could just be a byte
        stream interface, but you lose metadata such as timestamps.</li>
      <li> An OK stat includes the number of octets actually read.
        Probably passed back in datum, so unneeded here.</li>
      <li> The offset indicates a message number (sequential starting
        from zero). The value –1 indicates any new messages.</li>
      <li> Very roughly corresponds to Palmer's read (reads a named
        message) and watch (reads the oldest message since a specified
        time) [Dab13a] and subscribe(name, query, qos, cost) [Dab13b],
        where name is the name of the GCL, query is a condition that any
        returned messages must satisfy, qos is the required quality of
        service, and cost is undefined. It isn't clear if these are
        supposed to be iterators or one-time calls.</li>
    </ul>
    <hr size="2" width="100%">
    <h2>3&nbsp; GCL Asynchronous Operation (Subscriptions and Events)<br>
    </h2>
    <p>Asynchronous operations allow an application to subscribe to one
      or more GCLs and receive events as those GCLs see activity.&nbsp;
      The event mechanism is intended to be extensible for possible
      future expansion.<br>
    </p>
    <p>Every event has a type, a pointer to the GCL handle, and a
      pointer to a datum.&nbsp; Applications could in principle define
      their own event types, but at the moment this functionality is not
      exposed.<br>
    </p>
    <p>It is important that applications free any events after they have
      completed using them.<br>
    </p>
    <hr size="2" width="100%">
    <h4> Name</h4>
    gdp_gcl_subscribe — Subscribe to a readable GCL&nbsp; <strong><em>[PARTIALLY
        IMPLEMENTED]</em></strong><br>
    <h4> Synopsis</h4>
    <pre>EP_STAT gdp_gcl_subscribe(gdp_gcl_t *gcl,
		gdp_recno_t start,<br>		gdp_recno_t stop,
		gdp_gcl_sub_cbfunc_t cbfunc,<br>		void *cbdata)

void (*cbfunc)(gdp_gcl_t *gclhandle,
		gdp_datum_t *datum,
		void *cbdata)
</pre>
    <h4> Notes</h4>
    <ul>
      <li> If a cbfunc is specified, arranges to call callback when a
        message is generated on the gclhandle.</li>
      <li> The void *cbdata is passed through untouched.</li>
      <li> The callback is not necessarily invoked instantly, and may or
        may not be called in a separate thread.</li>
      <li>If no cbfunc is specified, subscription information is
        available through the gdp_gcl_event interface (see below).<br>
      </li>
      <li> The <code>start</code> parameter tells when to start the
        subscription (that is, the starting record number).&nbsp; When
        the record number gets to the <code>stop</code> parameter the
        subscription is terminated.</li>
      <li><em>Callbacks, start, and stop are not implemented at this
          time.</em><br>
      </li>
    </ul>
    <br>
    <hr size="2" width="100%">
    <h4> Name</h4>
    gdp_gcl_unsubscribe — Unsubscribe from a GCL&nbsp; <i><b>[NOT
        IMPLEMENTED]</b></i><br>
    <h4> Synopsis</h4>
    <pre>EP_STAT gdp_gcl_unsubscribe(gdp_gcl_t *gclhandle,
		cbfunc,
		void *cbdata)
</pre>
    <h4> Notes</h4>
    <ul>
      <li> Unsubscribes to the given {gclhandle, cbfunc, cbdata} tuple.</li>
    </ul>
    <br>
    <hr size="2" width="100%">
    <h4> Name</h4>
    gdp_event_next — get next asynchronous event<br>
    <h4> Synopsis</h4>
    <pre>gdp_event_t *gdp_event_next(bool wait)</pre>
    <h4> Notes</h4>
    <ul>
      <li> Returns the next asynchronous event.</li>
      <li>Currently the only asynchronous events are data arriving as
        the result of a subscription.</li>
    </ul>
    <hr size="2" width="100%">
    <h4>Name</h4>
    gdp_event_gettype — extract the type from the event<br>
    <h4>Synopsis</h4>
    <pre>int gdp_event_gettype(gdp_event_t *gev)</pre>
    <h4>Notes</h4>
    <ul>
      <li>The only type defined at present is GDP_EVENT_DATA, indicating
        data has arrived as the result of a subscription request.<br>
      </li>
    </ul>
    <hr size="2" width="100%">
    <h4>Name</h4>
    gdp_event_getgcl — extract the GCL handle from the event<br>
    <h4>Synopsis</h4>
    <pre>gdp_gcl_t *gdp_event_getgcl(gdp_event_t *gev)</pre>
    <h4>Notes</h4>
    <ul>
      <li>Returns the GCL handle that triggered this event.</li>
    </ul>
    <hr size="2" width="100%">
    <h4>Name</h4>
    gdp_event_getdatum — get the datum associated with this event<br>
    <h4>Synopsis</h4>
    <pre>gdp_datum_t *gdp_event_getdatum(gdp_event_t *gev)</pre>
    <h4>Notes</h4>
    <ul>
      <li>Returns the data associated with the event.</li>
    </ul>
    <hr size="2" width="100%">
    <p><br>
    </p>
    <h2>4&nbsp; Datums (Records)</h2>
    <p>GCLs are represented as a series of records of type <code>gdp_datum_t</code>.&nbsp;
      Each record has a record number, a commit timestamp, and
      associated data.&nbsp; Record numbers are of type <code>gdp_recno_t</code>
      and count up by one as records are added (i.e., record numbers are
      unique within a GCL and dense).&nbsp; Data is represented in
      dynamic buffers, as described below.<br>
    </p>
    <h3>4.1&nbsp; Timestamps</h3>
    <p>The time abstraction is imported directly from the ep
      library.&nbsp; Times are represented as follows:<br>
    </p>
    <blockquote>
      <pre><code>#pragma pack(push, 1)
typedef struct
{
     int64_t	tv_sec;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // seconds since January 1, 1970</code><code>
    </code><code>&nbsp;uint32_t&nbsp;&nbsp; tv_nsec;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // nanoseconds<br>     float&nbsp;&nbsp;&nbsp;&nbsp;  tv_accuracy;&nbsp;&nbsp;&nbsp; // accuracy in seconds<br></code><code>} EP_TIME_SPEC;<br>#pragma pack(pop)</code><code></code></pre>
    </blockquote>
    <pre><code></code></pre>
    <code><tt> </tt></code>Note that the host system <code>struct
      timespec</code> may not match this structure; some systems still
    represent the time with only four bytes for <code>tv_sec</code>,
    which expires in 2038.&nbsp; The <code>tv_accuracy</code> field
    indicates an estimate for how accurate the clock is; for example, if
    you are running NTP this value is likely to be on the order of a few
    tens to a few hundreds of milliseconds, but if you set your clock
    manually it is likely to be several seconds or worse.<br>
    <br>
    <h3>4.2&nbsp; Data Buffers</h3>
    <p>Data buffers grow dynamically as needed.<br>
    </p>
    <hr size="2" width="100%">
    <h4>Name</h4>
    gdp_buf_new, gdp_buf_reset, gdp_buf, free — allocate, reset, or free
    a buffer<br>
    <h4>Synopsis</h4>
    <pre>gdp_buf_t *gdp_buf_new(void)<br>void gdp_buf_reset(gdp_buf_t *b)<br>void gdp_buf_free(gdp_buf_t *b)<br><br></pre>
    Notes<br>
    <ul>
      <li>gdp_buf_new creates a new, empty buffer.</li>
      <li>gdp_buf_reset clears the buffer, leaving it in the same
        condition as when it was first created.</li>
      <li>gdp_buf_free frees the buffer.&nbsp; It must not be used again
        after being freed.</li>
    </ul>
    <hr size="2" width="100%">
    <h4>Name</h4>
    gdp_buf_getlength — return the length of the data in the buffer<br>
    <h4>Synopsis</h4>
    <pre>size_t gdp_buf_getlength(gdp_buf_t *b)</pre>
    <h4>Notes</h4>
    <ul>
      <li>Returns the number of bytes of data currently in the buffer.</li>
    </ul>
    <hr size="2" width="100%">
    <h4>Name</h4>
    gdp_buf_read, gdp_buf_peek, gdp_buf_drain — remove or peek at data
    in a buffer<br>
    <h4>Synopsis</h4>
    <pre>size_t gdp_buf_read(gdp_buf_t *b, void *out, size_t sz)<br>size_t gdp_buf_peek(gdp_buf_t *b, void *out, size_t sz)<br>int gdp_buf_drain(gdp_buf_t *b, size_t sz)<br></pre>
    <h4>Notes</h4>
    <ul>
      <li>Data can be consumed from the buffer by calling gdp_buf_read;
        data is copied from the buffer into a memory area.</li>
      <li>Applications can "peek" at the buffer using
        gdp_buf_peek.&nbsp; This is identical to gdp_buf_read except
        that the data remains in the buffer.</li>
      <li>Applications can discard data from the buffer using
        gdp_buf_drain.</li>
      <li>In all cases, sz is the number of bytes to copy out and/or
        discard.</li>
    </ul>
    <hr size="2" width="100%">
    <h4>Name</h4>
    gdp_buf_write, gdp_buf_printf — copy data into a buffer<br>
    <h4>Synopsis</h4>
    <pre>int gdp_buf_write(gdp_buf_t *b, void *in, size_t sz)<br>int gdp_buf_printf(gdp_buf_t *b, const char *fmt, ...)<br></pre>
    <h4>Notes</h4>
    <ul>
      <li>These routines insert bytes into the named buffer.</li>
      <li><code>gdp_buf_write</code> copies <code>sz</code> bytes into
        the buffer from the memory area in and returns 0 on success or
        –1 on failure.<br>
      </li>
      <li><code>gdp_buf_printf</code> essentially does a "printf" into
        the buffer and returns the number of bytes appended.<br>
      </li>
    </ul>
    <hr size="2" width="100%">
    <h4>Name</h4>
    gdp_buf_copy — copy data from one buffer into another<br>
    <h4>Synopsis</h4>
    <pre>int gdp_buf_copy(gdp_buf_t *ib, gdp_buf_t *ob)<br></pre>
    <h4>Notes</h4>
    <ul>
      <li>Appends the entire contents of <code>ib</code> to the end of
        <code>ob</code>.</li>
      <li>This is more efficient than using <code>gdp_buf_read</code>
        and <code>gdp_buf_write</code>.</li>
    </ul>
    <hr size="2" width="100%">
    <h4>Name</h4>
    gdp_buf_dump — print the contents of the buffer for debugging<br>
    <h4>Synopsis</h4>
    <pre>void gdp_buf_dump(gdp_buf_t *b, FILE *fp)</pre>
    <h4>Notes</h4>
    <ul>
      <li>Prints the contents of buffer b to the file fp.</li>
      <li>This is not intended for end user presentation.</li>
    </ul>
    <hr size="2" width="100%">
    <h3>4.3&nbsp; Datums</h3>
    <hr size="2" width="100%">
    <h4>Name</h4>
    <p>gdp_datum_new, gdp_datum_free, gdp_datum_print —
      allocate/free/print a datum structure<br>
    </p>
    <h4>Synopsis</h4>
    <pre>gdp_datum_t *gdp_datum_new(void)<br>void gdp_datum_free(gdp_datum_t *datum)<br>void gdp_datum_print(const gdp_datum_t *datum, FILE *fp)<br></pre>
    <h4>Notes</h4>
    <ul>
      <li><code>gdp_datum_new</code> allocates a new empty datum.</li>
      <li><code>gdp_datum_free</code> frees a datum.</li>
      <li><code>gdp_datum_print</code> writes a description of the datum
        (including the data contents) to the given file.</li>
    </ul>
    <hr size="2" width="100%">
    <h4>Name</h4>
    gdp_datum_getrecno, gdp_datum_setrecno — get/set the record number
    from a datum<br>
    <h4>Synopsis</h4>
    <pre>    <tt>gdp_recno_t gdp_datum_getrecno(const gdp_datum_t *datum)
    </tt><tt>void gdp_datum_setrecno(gdp_datum_t *datum,<br>                            gdp_recno_t recno)</tt></pre>
    <h4>Notes<br>
    </h4>
    <hr size="2" width="100%">
    <h4>Name</h4>
    gdp_datum_getts, gdp_datum_setts — get/set the timestamp from a
    datum<br>
    <h4>Synopsis</h4>
    <pre>
    void gdp_datum_getts(const gdp_datum_t *datum, EP_TIME_SPEC *ts)
    void gdp_datum_setts(gdp_datum_t *datum, EP_TIME_SPEC *ts)</pre>
    <h4>Notes</h4>
    <hr size="2" width="100%">
    <h4>Name</h4>
    gdp_datum_getdbuf — get the data buffer from a datum<br>
    <h4>Synopsis</h4>
    <pre>    gdp_buf_t *gdp_datum_getdbuf(const gdp_datum_t *datum)</pre>
    <h4>Notes</h4>
    <p><br>
    </p>
    <ul>
    </ul>
    <hr size="2" width="100%">
    <p><br>
    </p>
    <h2> 5&nbsp; Compiling and Linking</h2>
    The GDP library uses a reduced version of libep and also uses the
    libevent library version 2.1. These will need to be included both
    during compilation and linking.<br>
    At compile time you must use:<br>
    <pre>-I<i>libevent_includes_parent</i> -I<i>libep_includes_parent</i></pre>
    Note that these take the parent of the directory containing the
    include files. For example, if the include files for libevent are in
    /usr/local/include/event2 and the include files for libep are in
    /usr/local/include/ep you only need to specify the one flag
    "-I/usr/local/include".<br>
    For linking you must use:<br>
    <pre>-L<i>libevent_libraries</i> -levent -levent_pthreads -L<i>libep_libraries</i> -lep</pre>
    As before, if the libraries for libevent and libep are in the same
    directory you only need a single <tt>-L</tt> flag.<br>
    Libep is a library that I produced several years ago intended for
    use in sendmail. This uses a stripped down version of that library
    that excludes several things that would not be helpful here. For
    more details of the original (full) library, see <a
href="http://www.neophilic.com/blogs/eric.php/2014/05/12/libep-portable-c-runtime">http://www.neophilic.com/blogs/eric.php/2014/05/12/libep-portable-c-runtime</a>.<br>
    <h2> 6&nbsp; Open Questions</h2>
    <h3> 6.1 Access Control</h3>
    <p> Do this using Access Control Lists (so each user/app has a
      keypair) or by passing public/private keys around (so each GCL has
      a private keypair). The latter makes revocation impossible (even
      for write access), so I prefer the ACL approach. Third way?</p>
    <p> Revocation? Deep vs. Shallow. Deep = take away permissions that
      have already been given. Shallow = you can only prevent an
      accessor from getting to new versions. Argument: deep revocation
      is hard to do from a technical perspective and ultimately futile
      (someone might have taken a photo of a screen while they still had
      access), but is still what people are used to (Unix and SQL
      permissions work this way). Shallow is all that can really be
      guaranteed. Also, anything involving Certificate Revocation Lists
      (CRLs) is doomed to failure. This implies that ACLs are the
      correct direction.</p>
    <p> ACLs get us into the question of identity. Pretending that a
      keypair represents an identity doesn't work in the real world
      where bad players simply create new "identities" (keypairs) when
      an old identity has become untrusted. See the extensive work in
      email sender reputation. However, when a bad player creates a new
      identity/keypair they do not get access to any previous grants, so
      this may be sufficient.</p>
    <p> </p>
    <h3> 6.2 Naming</h3>
    <p> If each GCL has a private keypair, then the public key is
      sufficient to name the entity. If not, then assigning a GCL a GUID
      on creation seems like the best approach. Having the user assign a
      name seems like a non-starter, if only because of the possibility
      of conflicts.</p>
    <p> There will probably be some need for external naming, e.g., some
      overlay directory structure. That might be a different gcl_type.</p>
    <p> This seems like an open research topic.</p>
    <p> </p>
    <h3> 6.3 Orphans, Expiration, Charging, and Accounting</h3>
    <p> If a GCL isn't linked into a directory structure and everyone
      forgets its name then it will live forever (or until it expires).
      This could be quite common if a GCL is temporary, that is, not a
      candidate for long-term archival.</p>
    <p> Expiration could be an issue without some sort of charging,
      which implies accounting.</p>
    <p> Charging and accounting will affect the API. It seems like on
      GCL creation the creator needs to offer payment for both carrying
      and storing the data. This payment would presumably accrue to the
      actors providing the actual service. Payment for storage might be
      limited time or indefinite time (i.e., it would be an endowment).</p>
    <p> The creator could also specify a cost for any potential consumer
      in order to access the GCL. Such payments would accrue to the
      creator of the GCL, and might be used to fund continued access,
      i.e. it could be rolled back into the endowment. This would lean
      toward making less-used data disappear: appealing in some ways,
      but anathema to librarians and historians.</p>
    <p> As for API effects, it seems that GCL creation needs to include
      a payment for initial service, a cost for access, and an account
      into which to deposit any consumer payments. Accessing a GCL only
      requires an offered payment (which is probably best viewed as a
      bid rather than a payment, thus allowing multiple providers to
      compete for access).</p>
    <p> Note that none of this is dependent on the form of payment. It
      does however assume that there is a mutually agreed upon form of
      payment, i.e., a universal currency.</p>
    <p> </p>
    <h3> 6.4 GCL Content — Message vs. Byte Stream, Timestamping</h3>
    <p> Is the data inside a GCL a Unix-style stream of bytes or a
      record/message abstraction?</p>
    <p> Is timestamping something that should be supported at this level
      or higher? Timestamping will require a message-based abstraction.
      Note that there are really two timestamps: a "commit" timestamp
      that indicates official entry into the dataplane and a "sample"
      timestamp that is inserted as close to the sensor as possible and
      is arguably an application-level concern.</p>
    <p> </p>
    <h3> 6.5 GCL Write Semantics</h3>
    <p> Is there a way to overwrite a GCL in place (even if that means
      create a new version using copy-on-write)?</p>
    <p> Is there a way to overwrite a GCL in place (even if that means
      create a new version using copy-on-write)? If everything is
      actually append-only then databases become more interesting, but
      not impossible.</p>
    <p> This will impact the ease of providing Posix file semantics to
      applications.</p>
    <p> ANSWER: No overwrite.</p>
    <p> </p>
    <h3> 6.6 Quality of Service</h3>
    <p> Is Quality of Service specified on a particular GCL, a
      particular open instance of a GCL, or between a pair of endpoints?</p>
    <p> What does QoS actually mean? For example, in a live media stream
      it probably means the resolution of the data stream (which
      determines real-time bandwidth), latency, and possibly jitter, but
      after that stream is stored the QoS will be resolution (as
      before), delivery bandwidth (how quickly you can download the
      video, for example), and possibly jitter of the network connection
      (that is, how even the data flow will be). Delivery bandwidth
      depends on the entire path between the data source and the data
      sync, and may be higher or lower than the bandwidth required to
      send a real-time version of the stream — for example, over a slow
      network link.</p>
    <p> </p>
    <h2> Appendix A: References</h2>
    <br>
    <table width="100%" border="1" cellpadding="2" cellspacing="2">
      <tbody>
        <tr>
          <td valign="top">[Dab13a]<br>
          </td>
          <td valign="top">Palmer Dabbelt, Swarm OS Universal Dataplane,
            August 22, 2013</td>
        </tr>
        <tr>
          <td valign="top">[Dab13b]</td>
          <td valign="top">Palmer Dabbelt, What is the Universal
            Dataplane, Anyway?, September 17, 2013</td>
        </tr>
      </tbody>
    </table>
    <br>
    <br>
  </body>
</html>
