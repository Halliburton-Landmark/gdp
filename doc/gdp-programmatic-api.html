<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <meta content="text/html; charset=windows-1252"
      http-equiv="content-type">
    <title>Global Data Plane Programmatic API</title>
  </head>
  <body>
    <h1>Global Data Plane Programmatic API Proposal</h1>
    <h4>Editor: Eric Allman, U.C. Berkeley Swarm Lab,
      eric@cs.berkeley.edu</h4>
    <h5>Version 0.5, 2014-08-24</h5>
    <br>
    <p>
      This is a strawman proposal. It is not complete. Note that this
      does
      not include the in-system representation except where that impacts
      the
      API, nor does it discuss discovery at this time. It is only about
      a
      C-level API (in particular, not about a network-protocol level;
      Ben
      Zhang and Chang Lan have a proposal for that level). We'll need
      bindings for languages such as C++ and Python; I've tried to keep
      this
      proposal reasonably consistent with that requirement.</p>
    <p>
      How does AVB fit into this? Need to provide resource requirements
      on creation to be sure. What about opening?</p>
    <p>
      This is based in part on Palmer Dabbelt's papers "Swarm OS
      Universal
      Dataplane" [Dab13a] and "What is the Universal Dataplane, Anyway?"
      [Dab13b]. He had two slightly different interfaces in those two
      papers,
      the first using read, write. watch, provide, and request and the
      second
      using publish, subscribe, request, and provide. Palmer's interface
      request(query, qos, cost) requests access to an “aardvark”
      (now called a GDP Channel-Log or GCL) that matches the given query
      given that another service can provide the at least requested QoS
      for
      at most the requested cost; provide(name, qos, cost) asserts that
      this
      service is capable of providing access to the named aardvark under
      the
      constraints of the given qos and for the provided cost.</p>
    <p>
      Note: there is code implementing most of this proposal. It only
      operates on a single machine and isn't particularly fast.</p>
    <br>
    <h2>
      1 Theory of Operation</h2>
    <p>
      GDP-based applications rely on two pieces: an in-process GDP
      library
      and a GDP Daemon. The GDP Daemon does most of the heavy
      lifting; it will be described in a different document.</p>
    <p>
      The primary point of the GDP library is to speak the network
      protocol
      between the API and the GDP Daemon. The library is threaded, with
      (at the moment) two threads: one to process events (data arriving
      from
      the daemon, although others can be added), and the other to run
      the
      application itself. This allows the application to pretend it is
      a sequential program while still allowing asynchronous input from
      the
      GDP Daemon (e.g., processing results from subscription requests).</p>
    <p>
      The primary abstraction is the GDP Channel-Log (GCL). A GCL
      represents the rendezvous point for communication in the data
      plane. It
      is not directly tied to either a file or a network connection. On
      creation, a GCL is assigned a name, which is just a random UUID
      [maybe;
      see discussion]. A GCL is append-only to writers (true or false?).
      Palmer called this an aardvark, for lack of a better name.</p>
    <p style="font-style: italic;">
      [[Really need more here.]]</p>
    <h2>
      2 API</h2>
    <p>
      For the moment you can access the dataplane in one of two modes:
      synchronous mode (using gdp_gcl_read for reading) an asynchronous
      mode
      (using gdp_gcl_subscribe for reading). To use it in asynchronous
      mode
      you must subscribe to any GCLs of interest and then call
      gdp_gcl_evloop.</p>
    <h3>
      2.1 Data Structures</h3>
    <br>
    <hr size="2" width="100%">
    <h4>
      Name</h4>
    tt_interval_t — TrueTime-style interval<br>
    <h4>
      Synopsis</h4>
    <pre>#include &lt;gdp/gdp_timestamp.h&gt;

typedef struct timespec&nbsp; tt_stamp_t;

typedef struct
{
	tt_stamp_t	stamp;		// center of interval
	uint32_t	accuracy;	// clock accuracy in nanoseconds
} tt_interval_t;
</pre>
    <h4>
      Notes</h4>
    <ul>
      <li>
        A struct timespec contains fields tv_sec (seconds since January
        1, 1970) and tv_nsec (nanoseconds).</li>
      <li>
        The actual time range is the stamp ± accuracy / 2.</li>
      <li>
        This accuracy probably isn’t enough; it only allows four seconds
        of drift and only goes down to 10–9 seconds (some clocks have
        accuracy as low as 10–14 seconds). There are at least four
        solutions: (1) drop the resolution to microseconds to get the
        necessary
        range and assume we’ll never need to represent a more accurate
        clock; (2) change the data type to uint64_t and represent it in
        femtoseconds (10–15), at the cost of sending more network bits
        that usually have no meaning; (3) change the accuracy to 31 bits
        of
        microseconds and if the remaining bit is set have another 32
        bits
        representing femtoseconds; or (4) represent the accuracy as a
        32-bit
        floating point number.</li>
      <li>
        There is also a defined constant TT_NOTIME that indicates that
        the timestamp is invalid (in the stamp.tv_sec field).</li>
    </ul>
    <br>
    <hr size="2" width="100%">
    <h4>
      Name</h4>
    gdp_datum_t — A GDP record/entry/datum<br>
    <h4>
      Synopsis</h4>
    <pre>#include &lt;gdp/gdp.h&gt;

typedef struct
{
	tt_interval_t&nbsp;&nbsp;&nbsp;ts;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // timestamp for this message
	long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   recno;&nbsp;&nbsp;&nbsp;&nbsp; // the record number
	gdp_buf_t &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *dbuf;&nbsp;&nbsp;&nbsp; &nbsp;// the data buffer
	size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   dlen;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // length of data
	(private data omitted)
} gdp_datum_t;
</pre>
    <h4>
      Notes</h4>
    <ul>
      <li>
        It isn't clear that recno should be public.</li>
    </ul>
    <br>
    <h3>
      2.2 Functions</h3>
    <br>
    <hr size="2" width="100%">
    <h4>
      Name</h4>
    gdp_init — Initialize the GDP library<br>
    <h4>
      Synopsis</h4>
    <pre>EP_STAT gdp_init(void)
</pre>
    <h4>
      Notes</h4>
    <ul>
      <li>
        Initializes the GDP library.&nbsp; <em><strong>Must</strong></em>
        be called before any other GDP functions are invoked.<br>
      </li>
    </ul>
    <br>
    <hr size="2" width="100%">
    <h4>
      Name</h4>
    gdp_gcl_print — print a GCL handle (for debugging)<br>
    <h4>Synopsis</h4>
    <pre>void gdp_gcl_print(const gdp_gcl_t *gclh, FILE *fp)</pre>
    <h4>Notes</h4>
    <ul>
      <li>Prints the GCL on the indicated file.</li>
    </ul>
    <p><br>
    </p>
    <hr size="2" width="100%">
    <h4>
      Name</h4>
    gdp_gcl_create — Create an append-only GCL<br>
    <h4>
      Synopsis</h4>
    <pre>EP_STAT gdp_gcl_create(gcl_name_t gcl_name,
		gdp_gcl_t **gclhandlep)
</pre>
    <h4>
      Notes</h4>
    <ul>
      <li>
        Creates a GCL with the given name, which must be a 256-bit value
        (e.g., the hash of a human-meaningful string).</li>
      <li>
        Returns a GCL handle.</li>
      <li>
        The gclhandle is writable (but can it be readable?)</li>
      <li>
        We probably need payment information, some way of specifying
        resource requirements, and so forth.</li>
      <li>
        Palmer did not describe anything that explicitly creates a GCL.
        I think
        explicit creation is important, but the semantics could be
        automatic
        creation on first reference.</li>
    </ul>
    <br>
    <hr size="2" width="100%">
    <h4>
      Name</h4>
    gdp_gcl_open — Open an existing GCL<br>
    <h4>
      Synopsis</h4>
    <pre>EP_STAT gdp_gcl_open(gcl_name_t name,
		gcl_iomode_t rw,
		gdp_gcl_t **gclhandle)
</pre>
    <h4>
      Notes</h4>
    <ul>
      <li>
        Pass in type/subtype? That would make it seem to be part of the
        naming.
        Alternatively there could be a "requirements" parameter that
        would
        specify this information as well as QoS requirements. This could
        be
        useful.</li>
      <li>
        Can handles be R/W or are the only options RO or AO (Append
        Only)? Or
        for that matter can you update an existing GCL (overwrite) by
        cloning a
        new version (e.g., using CoW)?</li>
      <li>
        Do we have to pass in a permission token? This could be a key.
        If GCLes
        are named by their public key then this will be implicit, but if
        ACLs
        are used then the identity (more likely some proxy for the
        identity)
        will have to be passed in. Some applications might even want to
        have
        multiple identities based on their roles.</li>
      <li>
        It may be useful to pass in a "payment" parameter. See
        discussion below.</li>
      <li>
        Perhaps qos should be replaced by a descriptor parameter a la
        gdp_gcl_create.</li>
    </ul>
    <br>
    <hr size="2" width="100%">
    <h4>
      Name</h4>
    gdp_gcl_publish — Publish (append) a record to a writable GCL<br>
    <h4>
      Synopsis</h4>
    <pre>EP_STAT gdp_gcl_publish(gdp_gcl_t *gclhandle,
		gdp_datum_t *datum)
</pre>
    <h4>
      Notes</h4>
    <ul>
      <li>
        Appends the indicated datum to the GCL.</li>
      <li>Any subscribers get immediate updates about this publication.</li>
      <li><i>Does this return before the data is actually committed or
          after? If
          before it may be hard to correlate errors to appends. If after
          there
          will probably be performance issues.</i></li>
      <li><i>
          Should writes be asynchronous at this level? Could pass in a
          message id
          which can be returned in something like a gdp_gcl_sync() call.
          Easy to
          build synchronous on top of asynchronous.</i></li>
      <li><i>
          Corresponds to Palmer's write [Dab13a] and publish(name,
          message)
          [Dab13b], where name is the name of the GCL and message is the
          data.</i></li>
      <li><i>
          Messages written into a GCL become available to gdp_gcl_read
          and to functions registered with gdp_gcl_subscribe.</i></li>
      <li><i>
          This definition assumes an octet-stream-based interface. If a
          message-based interface is chosen then this obviously changes.
          The
          correct abstraction under those assumptions probably passes in
          a
          message, which is a structure including time and location
          information
          as well as the data itself. See the discussion in the next
          section.</i></li>
    </ul>
    <br>
    <hr size="2" width="100%">
    <h4>
      Name</h4>
    gdp_gcl_read — Read from a readable GCL<br>
    <h4>
      Synopsis</h4>
    <pre>EP_STAT gdp_gcl_read(gdp_gcl_t *gclhandle,
		gdp_recno_t recno,
		gdp_datum_t *datum)
</pre>
    <h4>
      Notes</h4>
    <ul>
      <li>
        Reads the specified record number and returns it in the
        user-supplied datum (see below).</li>
      <li>Assumes a message-oriented interface. It could just be a byte
        stream interface, but you lose metadata such as timestamps.</li>
      <li>
        An OK stat includes the number of octets actually read. Probably
        passed back in datum, so unneeded here.</li>
      <li>
        The offset indicates a message number (sequential starting from
        zero). The value –1 indicates any new messages.</li>
      <li>
        Very roughly corresponds to Palmer's read (reads a named
        message) and
        watch (reads the oldest message since a specified time) [Dab13a]
        and
        subscribe(name, query, qos, cost) [Dab13b], where name is the
        name of
        the GCL, query is a condition that any returned messages must
        satisfy,
        qos is the required quality of service, and cost is undefined.
        It isn't
        clear if these are supposed to be iterators or one-time calls.</li>
    </ul>
    <br>
    <hr size="2" width="100%">
    <h4>
      Name</h4>
    gdp_gcl_watch — Read from a readable GCL, waiting for a result&nbsp;
    <i><b>[NOT IMPLEMENTED]</b></i>
    <h4>
      Synopsis</h4>
    <pre>EP_STAT gdp_gcl_watch(gdp_gcl_t *gclhandle,
		gdp_recno_t recno,
		gdp_datum_t *datum)
</pre>
    <h4>
      Notes</h4>
    <ul>
      <li>
        Behaves exactly like <code>gdp_gcl_read</code>, but if the
        message doesn't yet exist
        it waits for it to appear for up to the indicated timeout.</li>
    </ul>
    <hr size="2" width="100%">
    <h4>Name</h4>
    <p>gdp_datum_new, gdp_datum_free, gdp_datum_print —
      allocate/free/print a datum structure<br>
    </p>
    <h4>Synopsis</h4>
    <pre>gdp_datum_t *gdp_datum_new(void)<br>void gdp_datum_free(gdp_datum_t *datum)<br>void gdp_datum_print(const gdp_datum_t *datum, FILE *fp)<br></pre>
    <h4>Notes</h4>
    <ul>
      <li>gdp_datum_new allocates a new empty datum.</li>
      <li>gdp_datum_free frees a datum.</li>
      <li>gdp_datum_print writes a description of the datum (including
        the data contents) to the given file.<br>
      </li>
    </ul>
    <br>
    <hr size="2" width="100%">
    <h4>
      Name</h4>
    gdp_gcl_subscribe — Subscribe to a readable GCL<br>
    <h4>
      Synopsis</h4>
    <pre>EP_STAT gdp_gcl_subscribe(gdp_gcl_t *gcl,
		gdp_recno_t start,<br>		gdp_recno_t stop,
		gdp_gcl_sub_cbfunc_t cbfunc,<br>		void *cbdata)

void (*cbfunc)(gdp_gcl_t *gclhandle,
		gdp_datum_t *datum,
		void *cbdata)
</pre>
    <h4>
      Notes</h4>
    <ul>
      <li>
        If a cbfunc is specified, arranges to call callback when a
        message is generated on the gclhandle.</li>
      <li>
        The void *cbdata is passed through untouched.</li>
      <li>
        The callback is not necessarily invoked instantly, and may or
        may not be called in a separate thread.</li>
      <li>If no cbfunc is specified, subscription information is
        available through the gdp_gcl_event interface (see below).<br>
      </li>
      <li>
        The <code>start</code> parameter tells when to start the
        subscription (that is, the starting record number).&nbsp; When
        the record number gets to the <code>stop</code> parameter the
        subscription is terminated.</li>
      <li><em>Callbacks, start, and stop are not implemented at this
          time.</em><br>
      </li>
    </ul>
    <br>
    <hr size="2" width="100%">
    <h4>
      Name</h4>
    gdp_gcl_unsubscribe — Unsubscribe from a GCL&nbsp; <i><b>[NOT
        IMPLEMENTED]</b></i><br>
    <h4>
      Synopsis</h4>
    <pre>EP_STAT gdp_gcl_unsubscribe(gdp_gcl_t *gclhandle,
		cbfunc,
		void *cbdata)
</pre>
    <h4>
      Notes</h4>
    <ul>
      <li>
        Unsubscribes to the given {gclhandle, cbfunc, cbdata} tuple.</li>
    </ul>
    <br>
    <hr size="2" width="100%">
    <h4>
      Name</h4>
    gdp_event_next — get next asynchronous event<br>
    <h4>
      Synopsis</h4>
    <pre>gdp_event_t *gdp_event_next(bool wait)</pre>
    <h4>
      Notes</h4>
    <ul>
      <li>
        Returns the next asynchronous event.</li>
      <li>Currently the only asynchronous events are data arriving as
        the result of a subscription.</li>
    </ul>
    <hr size="2" width="100%">
    <h4>Name</h4>
    gdp_event_gettype — extract the type from the event<br>
    <h4>Synopsis</h4>
    <pre>int gdp_event_gettype(gdp_event_t *gev)</pre>
    <h4>Notes</h4>
    <ul>
      <li>The only type defined at present is GDP_EVENT_DATA, indicating
        data has arrived as the result of a subscription request.<br>
      </li>
    </ul>
    <hr size="2" width="100%">
    <h4>Name</h4>
    gdp_event_getgcl — extract the GCL handle from the event<br>
    <h4>Synopsis</h4>
    <pre>gdp_gcl_t *gdp_event_getgcl(gdp_event_t *gev)</pre>
    <h4>Notes</h4>
    <ul>
      <li>Returns the GCL handle that triggered this event.</li>
    </ul>
    <hr size="2" width="100%">
    <h4>Name</h4>
    gdp_event_getdatum — get the datum associated with this event<br>
    <h4>Synopsis</h4>
    <pre>gdp_datum_t *gdp_event_getdatum(gdp_event_t *gev)</pre>
    <h4>Notes</h4>
    <ul>
      <li>Returns the data associated with the event.</li>
    </ul>
    <p><br>
    </p>
    <hr size="2" width="100%">
    <h4>
      Name</h4>
    gdp_gcl_close — Close a GCL<br>
    <h4>
      Synopsis</h4>
    <pre>EP_STAT gdp_gcl_close(gdp_gcl_t *gclhandle)
</pre>
    <h4>
      Notes</h4>
    <ul>
      <li>
        Should this interface say whether to preserve or drop the GCL
        (i.e., is it persistent, or for how long)?</li>
    </ul>
    <br>
    <hr size="2" width="100%">
    <h4>
      Name</h4>
    gdp_gcl_getname — Return the name of a GCL<br>
    <h4>
      Synopsis</h4>
    <pre>EP_STAT gdp_gcl_getname(gdp_gcl_t *gclhandle,
		gcl_name_t namebuf)
</pre>
    <h4>
      Notes</h4>
    <ul>
      <li>
        Returns the name of the GCL referenced by gclhandle into
        namebuf.
        Assumes that names are a fixed size, otherwise will need a
        buffer
        length.</li>
      <li>
        May not be necessary if the creator provides the name; really
        only
        intended after gdp_gcl_create so that the name can be shared to
        other
        nodes that want to gdp_gcl_open it.</li>
    </ul>
    <br>
    <hr size="2" width="100%">
    <h4>
      Name</h4>
    gdp_gcl_getstat — Return information about a GCL <b>[NOT YET
      IMPLEMENTED]</b><br>
    <h4>
      Synopsis</h4>
    <pre>EP_STAT gdp_gcl_getstat(gdp_gcl_t *gclhandle,
		gcl_stat_t *statbuf)
</pre>
    <h4>
      Notes</h4>
    <ul>
      <li>
        What status is included? Size (or number of records/messages),
        type, subtype, last access, …</li>
      <li>
        What about type-dependent status information?</li>
      <li>
        Should this take a handle or a name? Or two interfaces?</li>
    </ul>
    <hr size="2" width="100%">
    <p><br>
    </p>
    <h3>
      2.3 Compiling and Linking</h3>
    The GDP library uses a reduced version of libep and also uses the
    libevent library version 2.1. These will need to be included both
    during compilation and linking.<br>
    At compile time you must use:<br>
    <pre>-I<i>libevent_includes_parent</i> -I<i>libep_includes_parent</i></pre>
    Note that these take the parent of the directory containing the
    include
    files. For example, if the include files for libevent are in
    /usr/local/include/event2 and the include files for libep are in
    /usr/local/include/ep you only need to specify the one flag
    "-I/usr/local/include".<br>
    For linking you must use:<br>
    <pre>-L<i>libevent_libraries</i> -levent -levent_pthreads -L<i>libep_libraries</i> -lep</pre>
    As before, if the libraries for libevent and libep are in the same
    directory you only need a single <tt>-L</tt> flag.<br>
    Libep is a library that I produced several years ago intended for
    use
    in sendmail. This uses a stripped down version of that library that
    excludes several things that would not be helpful here. For more
    details of the original (full) library, see
    <a
href="http://www.neophilic.com/blogs/eric.php/2014/05/12/libep-portable-c-runtime">http://www.neophilic.com/blogs/eric.php/2014/05/12/libep-portable-c-runtime</a>.<br>
    <h2>
      3 Open Questions</h2>
    <h3>
      3.1 Access Control</h3>
    <p>
      Do this using Access Control Lists (so each user/app has a
      keypair) or
      by passing public/private keys around (so each GCL has a private
      keypair). The latter makes revocation impossible (even for write
      access), so I prefer the ACL approach. Third way?</p>
    <p>
      Revocation? Deep vs. Shallow. Deep = take away permissions that
      have
      already been given. Shallow = you can only prevent an accessor
      from
      getting to new versions. Argument: deep revocation is hard to do
      from a
      technical perspective and ultimately futile (someone might have
      taken a
      photo of a screen while they still had access), but is still what
      people are used to (Unix and SQL permissions work this way).
      Shallow is
      all that can really be guaranteed. Also, anything involving
      Certificate
      Revocation Lists (CRLs) is doomed to failure. This implies that
      ACLs
      are the correct direction.</p>
    <p>
      ACLs get us into the question of identity. Pretending that a
      keypair
      represents an identity doesn't work in the real world where bad
      players
      simply create new "identities" (keypairs) when an old identity has
      become untrusted. See the extensive work in email sender
      reputation.
      However, when a bad player creates a new identity/keypair they do
      not
      get access to any previous grants, so this may be sufficient.</p>
    <p>
    </p>
    <h3>
      3.2 Naming</h3>
    <p>
      If each GCL has a private keypair, then the public key is
      sufficient to
      name the entity. If not, then assigning a GCL a GUID on creation
      seems
      like the best approach. Having the user assign a name seems like a
      non-starter, if only because of the possibility of conflicts.</p>
    <p>
      There will probably be some need for external naming, e.g., some
      overlay directory structure. That might be a different gcl_type.</p>
    <p>
      This seems like an open research topic.</p>
    <p>
    </p>
    <h3>
      3.3 Orphans, Expiration, Charging, and Accounting</h3>
    <p>
      If a GCL isn't linked into a directory structure and everyone
      forgets
      its name then it will live forever (or until it expires). This
      could be
      quite common if a GCL is temporary, that is, not a candidate for
      long-term archival.</p>
    <p>
      Expiration could be an issue without some sort of charging, which
      implies accounting.</p>
    <p>
      Charging and accounting will affect the API. It seems like on GCL
      creation the creator needs to offer payment for both carrying and
      storing the data. This payment would presumably accrue to the
      actors
      providing the actual service. Payment for storage might be limited
      time
      or indefinite time (i.e., it would be an endowment).</p>
    <p>
      The creator could also specify a cost for any potential consumer
      in
      order to access the GCL. Such payments would accrue to the creator
      of
      the GCL, and might be used to fund continued access, i.e. it could
      be
      rolled back into the endowment. This would lean toward making
      less-used
      data disappear: appealing in some ways, but anathema to librarians
      and
      historians.</p>
    <p>
      As for API effects, it seems that GCL creation needs to include a
      payment for initial service, a cost for access, and an account
      into
      which to deposit any consumer payments. Accessing a GCL only
      requires
      an offered payment (which is probably best viewed as a bid rather
      than
      a payment, thus allowing multiple providers to compete for
      access).</p>
    <p>
      Note that none of this is dependent on the form of payment. It
      does
      however assume that there is a mutually agreed upon form of
      payment,
      i.e., a universal currency.</p>
    <p>
    </p>
    <h3>
      3.4 GCL Content — Message vs. Byte Stream, Timestamping</h3>
    <p>
      Is the data inside a GCL a Unix-style stream of bytes or a
      record/message abstraction?</p>
    <p>
      Is timestamping something that should be supported at this level
      or
      higher? Timestamping will require a message-based abstraction.
      Note
      that there are really two timestamps: a "commit" timestamp that
      indicates official entry into the dataplane and a "sample"
      timestamp
      that is inserted as close to the sensor as possible and is
      arguably an
      application-level concern.</p>
    <p>
    </p>
    <h3>
      3.5 GCL Write Semantics</h3>
    <p>
      Is there a way to overwrite a GCL in place (even if that means
      create a new version using copy-on-write)?</p>
    <p>
      Is there a way to overwrite a GCL in place (even if that means
      create a
      new version using copy-on-write)? If everything is actually
      append-only
      then databases become more interesting, but not impossible.</p>
    <p>
      This will impact the ease of providing Posix file semantics to
      applications.</p>
    <p>
      ANSWER: No overwrite.</p>
    <p>
    </p>
    <h3>
      3.6 Quality of Service</h3>
    <p>
      Is Quality of Service specified on a particular GCL, a particular
      open instance of a GCL, or between a pair of endpoints?</p>
    <p>
      What does QoS actually mean? For example, in a live media stream
      it
      probably means the resolution of the data stream (which determines
      real-time bandwidth), latency, and possibly jitter, but after that
      stream is stored the QoS will be resolution (as before), delivery
      bandwidth (how quickly you can download the video, for example),
      and
      possibly jitter of the network connection (that is, how even the
      data
      flow will be). Delivery bandwidth depends on the entire path
      between
      the data source and the data sync, and may be higher or lower than
      the
      bandwidth required to send a real-time version of the stream —
      for example, over a slow network link.</p>
    <p>
    </p>
    <h3>
      Appendix A: References</h3>
    <br>
    <table border="1" cellpadding="2" cellspacing="2" width="100%">
      <tbody>
        <tr>
          <td valign="top">[Dab13a]<br>
          </td>
          <td valign="top">Palmer Dabbelt, Swarm OS Universal Dataplane,
            August 22, 2013</td>
        </tr>
        <tr>
          <td valign="top">[Dab13b]</td>
          <td valign="top">Palmer Dabbelt, What is the Universal
            Dataplane, Anyway?, September 17, 2013</td>
        </tr>
      </tbody>
    </table>
    <br>
    <br>
  </body>
</html>
