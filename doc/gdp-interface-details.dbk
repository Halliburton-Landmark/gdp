<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<article>
  <articleinfo>
    <title>Global Data Plane Interface Details (And Thoughts on
    Implementation)</title>

    <subtitle>Straw Man Version 1</subtitle>

    <author>
      <firstname>Eric</firstname>

      <surname>Allman</surname>

      <affiliation>
        <orgname>U.C. Berkeley Swarm Lab</orgname>
      </affiliation>

      <email>eric@cs.berkeley.edu</email>
    </author>

    <pubdate>2014-06-04</pubdate>

    <releaseinfo>Incomplete Draft 2</releaseinfo>
  </articleinfo>

  <para>These are my thoughts on a possible model for the Global Data Plane
  interface and to a lesser extent the implementation. Much of this will not
  be in the initial implementation, but I want to start thinking about how it
  works now.</para>

  <para>A USC is named with a 128-bit identifier that might be either a GUID
  or a hash of the contents; the important point is that it be unique and, for
  performance reasons, reasonably evenly distributed (sequential integers
  would be a very bad idea indeed). We might consider using 160 bit names (the
  size of a SHA1 hash) or even 256-bit names (the size of a SHA256); that
  seems to be the direction the crypto community is going.</para>

  <section>
    <title>GDP Daemons</title>

    <para>There are at least four daemons in this model, probably more.
    I&rsquor;m calling them &ldquo;daemon&rdquor; here because Ken
    didn&rsquor;t like the word &ldquo;manager&rdquor; and suggested
    &ldquo;service&rdquor; instead, but these are not the same as the Swarm
    Services we have talked about in the past, so I think this is a very bad
    name. Daemons is at least descriptive and accurate.</para>

    <orderedlist>
      <listitem>
        <para>The Authentication Daemon (AD) is the central entry point for
        clients into the system and as such has to be discoverable.
        It&rsquor;s main job is to authenticate clients and pass them to a
        Layout Daemon. It will probably be necessary to allow
        &ldquo;authentication&rdquor; as a guest user, for example so a
        speaker can access a projector in the current room.</para>
      </listitem>

      <listitem>
        <para>The Layout Daemon (LD) controls how data is distributed among
        the various host nodes. It doesn&rsquor;t need to have the entire
        state of the world, but it does need to know how to communicate with
        other Layout Daemons and with the Data Daemon. It also understands
        about Quality of Service and can, for example, select a path that
        supports AVB if that is the only protocol that works &mdash; or return
        a failure to the client telling them that the requested QoS is not
        possible. Once the Layout Daemon knows what the client wants to do, it
        passes them to the Data Daemon. Ken correctly points out that there is
        really too much for one daemon, so this needs to be further
        decomposed. See below for Ken&rsquor;s model.</para>
      </listitem>

      <listitem>
        <para>The Data Daemon (DD) is the performance-critical piece that
        needs to talk with clients and other data Daemons. It is the meat of
        the GDP. This is the piece that most likely needs to be implemented in
        C. Its raison d&rsquor;&ecirc;tre is solely to shovel data from where
        it is to where it needs to be, but someone else (the LD, or whatever
        that turns into) decides where that is. It can be thought of as pure
        implementation; policy is handled elsewhere.</para>
      </listitem>

      <listitem>
        <para>The RESTful Daemon (RD) translates REST calls into GDP calls. In
        the description below the RD is in the role of a client.</para>
      </listitem>

      <listitem>
        <para>(Maybe) The GDP Daemon (GD). It is what gets started up,
        creating the other daemons and monitoring them. This will certainly be
        desirable during development and should probably be continued into
        deployment.</para>
      </listitem>

      <listitem>
        <para>(Maybe) The Economics Daemon (ED). This manages micropayments as
        necessary.</para>
      </listitem>
    </orderedlist>

    <para>Communication paths exist between the AD and ADs on other nodes as
    necessary, ADs and some set of LDs (including the LD on the local node),
    LDs and LDs on other nodes as necessary, LDs and some set of DDs
    (including the DD on the local node), and DDs with other DDs as necessary.
    All the internal communications between daemons are encrypted. Setting up
    these connections and mutual authentication is TBD.</para>

    <para>A sample session might proceed as follows:</para>

    <orderedlist>
      <listitem>
        <para>The client locates an Authentication Daemon. This represents the
        GDP Discovery phase.</para>
      </listitem>

      <listitem>
        <para>The client contacts the AD and authenticates. They immediately
        exchange a one-time session key and start encrypting the
        connection.</para>
      </listitem>

      <listitem>
        <para>The client informs the AD what it wants to do. This will most
        likely be to create a USC, append to an existing USC, or read an
        existing USC.</para>
      </listitem>

      <listitem>
        <para>The AD locates a Layout Daemon that can satisfy the requests,
        passes the session key to that LD, and points the client at that LD.
        At this point the client and the AD can disconnect.</para>
      </listitem>

      <listitem>
        <para>The client contacts the LD (encrypted and authenticated by the
        session key), and says what it wants to do (the same information as
        previously passed to the AD; alternatively the AD could pass this
        information to the LD along with the session key)</para>
      </listitem>

      <listitem>
        <para>The LD finds a Data Daemon that has the information necessary to
        complete that request. It&rsquor;s quite likely that the LD creates
        the USC if need be.</para>
      </listitem>

      <listitem>
        <para>The LD transfers control to the DD in the same way as the
        AD&rarr;LD handoff.</para>
      </listitem>

      <listitem>
        <para>The client interacts with the DD as necessary to do I/O. If
        necessary the DD forwards requests to other DDs. Normally the
        client&harr;DD connection persists through the session.</para>
      </listitem>

      <listitem>
        <para>When done, the client tells the DD to close. The DD informs the
        LD, which does any cleanup necessary. [We have the DD contact the LD
        directly so we don&rsquor;t have to special-case the case where a
        client unexpectedly disconnects.]</para>
      </listitem>
    </orderedlist>

    <para>If a client moves during the session, it is the responsibility of
    the LD to communicate with other LDs to find an appropriate DD that can
    continue the session.</para>
  </section>

  <section>
    <title>Network Protocol</title>

    <para>Ideally there will be a single network protocol that can work on all
    connections, but this isn&rsquor;t critical to operation. The following
    protocol is designed for client to DD (and probably DD to DD)
    communication.</para>

    <para>Network packets are binary for performance. They are laid out
    as:</para>

    <informaltable frame="box" rules="all">
      <col valign="top" width="1*" />

      <col valign="top" width="2*" />

      <col valign="top" width="15*" />

      <thead>
        <tr align="center">
          <th>Octets</th>

          <th>Name</th>

          <th>Comments</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>1</td>

          <td>command</td>

          <td>e.g., write, read, open, close; also used for status: success,
          failure</td>
        </tr>

        <tr>
          <td>3</td>

          <td>sequence</td>

          <td>A sequence number used to correlate requests and replies. The
          initiator chooses an unused value; the replier repeats that value
          back in the response. There is no requirement that this be
          monotonically increasing, or even that it be unique &mdash; it is
          purely for the convenience of the client.</td>
        </tr>

        <tr>
          <td>16 (20?)</td>

          <td>usc_id</td>

          <td>The name of the USC of interest</td>
        </tr>

        <tr>
          <td>4</td>

          <td>recno</td>

          <td>The record number (from 0 for each USC). If negative it will be
          interpreted as being &ldquo;from the end&rdquor;, so &ndash;1
          returns the last (most recent) record. Responses will always have an
          absolute record number.</td>
        </tr>

        <tr>
          <td>16</td>

          <td>timestamp</td>

          <td>The GDP commit timestamp for this record; see below for more
          information.</td>
        </tr>

        <tr>
          <td>4</td>

          <td>length</td>

          <td>The length of the data portion in octets.</td>
        </tr>

        <tr>
          <td>N</td>

          <td>data</td>

          <td>The data itself. The actual field is padded to the next higher
          four bytes; for example, if length is 5 then 8 bytes are transmitted
          but only five bytes are relevant.</td>
        </tr>
      </tbody>
    </informaltable>

    <para>Commands:</para>

    <informaltable frame="box" rules="all">
      <col valign="top" width="1*" />

      <col valign="top" width="2*" />

      <col valign="top" width="15*" />

      <thead>
        <tr align="center">
          <th>Command</th>

          <th>Name</th>

          <th>Comments</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>0</td>

          <td>Idle</td>

          <td>Used for keepalives (or maybe unused?)</td>
        </tr>

        <tr>
          <td>1</td>

          <td>Hello</td>

          <td>Initial startup handshake/authentication (details TBD)</td>
        </tr>

        <tr>
          <td>2</td>

          <td>Move</td>

          <td>Reserved for mobile nodes</td>
        </tr>

        <tr>
          <td></td>

          <td></td>

          <td></td>
        </tr>

        <tr>
          <td>8</td>

          <td>Create</td>

          <td>Creates a USC; the response returns the USC_id</td>
        </tr>

        <tr>
          <td>9</td>

          <td>Open_A</td>

          <td>Open an existing USC for append; the response repeats the
          USC_id</td>
        </tr>

        <tr>
          <td>10</td>

          <td>Open_R</td>

          <td>Open an existing USC for read; the response repeats the
          USC_id</td>
        </tr>

        <tr>
          <td>11</td>

          <td>Close</td>

          <td>Close a USC (that is, declare lack of interest)</td>
        </tr>

        <tr>
          <td></td>

          <td></td>

          <td></td>
        </tr>

        <tr>
          <td>16</td>

          <td>Read</td>

          <td>Read a given record number from a USC. The response includes the
          USC_id, the recno, and the timestamp as well as the data</td>
        </tr>

        <tr>
          <td>17</td>

          <td>Append</td>

          <td>Append to a given USC. The response includes the USC_id, the
          newly assigned recno, and the newly assigned timestamp. Question:
          should internal communications allow a timestamp to be passed?
          Probably.</td>
        </tr>

        <tr>
          <td>18</td>

          <td>Subscribe</td>

          <td>Tell the DD that you are interesting in getting spontaneous
          messages when a message is appended to a given USC_id.</td>
        </tr>

        <tr>
          <td>19</td>

          <td>Unsubscribe</td>

          <td>Could this just use Close instead?</td>
        </tr>

        <tr>
          <td></td>

          <td></td>

          <td></td>
        </tr>

        <tr>
          <td>192</td>

          <td>Ack/Data</td>

          <td>Successful response. Includes data if appropriate (e.g., in
          response to a read). If this is a spontaneous response resulting
          from a Subscribe, the sequence is set to the same value as the
          Subscribe message and the data is returned.</td>
        </tr>

        <tr>
          <td>193</td>

          <td>Nack/Error</td>

          <td>Failure response. Error detail is returned in the recno and/or
          data field (TBD)</td>
        </tr>

        <tr>
          <td>194</td>

          <td>Continue</td>

          <td>Intermediate response. For example, used during authentication
          exchanges to say &ldquo;proceed to next phase&rdquor;</td>
        </tr>

        <tr>
          <td></td>

          <td></td>

          <td></td>
        </tr>

        <tr>
          <td>255</td>

          <td>Reserved</td>

          <td></td>
        </tr>

        <tr>
          <td></td>

          <td></td>

          <td></td>
        </tr>
      </tbody>
    </informaltable>

    <para> Strictly speaking there is no need for the
    Open_<replaceable>X</replaceable> calls. It&rsquor;s my hunch that this
    will improve efficiency by allowing the system knowledge of intent. Close
    is necessary even without Open to flush subscriptions; it may also be
    useful for forcing commits. A spontaneously closed connection implies a
    Close.</para>

    <para></para>

    <para> </para>
  </section>

  <section>
    <title>On-Disk Representation</title>

    <para>The actual representation on disk is likely to depend a lot on the
    underlying structures, so this is pretty much a shot in the dark.
    It&rsquor;s designed for representation in a regular Unix file.</para>

    <para>An on-disk representation of a USC has three parts: a USC Header
    (probably a fixed length area), an index (for random access), and the data
    itself. It is intended that the index can be rebuilt from the data.</para>

    <para>The USC header consists of:</para>

    <informaltable frame="box" rules="all">
      <col valign="top" width="1*" />

      <col valign="top" width="2*" />

      <col valign="top" width="15*" />

      <thead>
        <tr align="center">
          <th>Octets</th>

          <th>Name</th>

          <th>Comments</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>4/8?</td>

          <td>usc_magic</td>

          <td>A magic number used to ensure that this really is a USC; I
          recommend the ASCII representation of &ldquo;gdp-USC&rdquor; or
          something similarly understandable.</td>
        </tr>

        <tr>
          <td>4</td>

          <td>usc_version</td>

          <td>A version number, useful for back compatibility.</td>
        </tr>

        <tr>
          <td>4</td>

          <td>header_length</td>

          <td>The length of the header.</td>
        </tr>

        <tr>
          <td>?</td>

          <td></td>

          <td>Probably other fields such as pointers to the index.</td>
        </tr>
      </tbody>
    </informaltable>

    <para>The structure of the index is TBD; I believe there is discussion of
    that in the Oceanstore paper. For a first pass implementation there might
    be an in-memory index only which is rebuilt when a USC is opened. This
    would make startup slow, but as long as USCes are small it should be
    acceptable for a first pass prototype.</para>

    <para>The data records consist of:</para>

    <informaltable frame="box" rules="all">
      <col valign="top" width="1*" />

      <col valign="top" width="2*" />

      <col valign="top" width="15*" />

      <thead>
        <tr align="center">
          <th>Octets</th>

          <th>Name</th>

          <th>Comments</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>4</td>

          <td>recno</td>

          <td>The sequence number of this record.</td>
        </tr>

        <tr>
          <td>16</td>

          <td>timestamp</td>

          <td>The USC commit timestamp for this record.</td>
        </tr>

        <tr>
          <td>4</td>

          <td>length</td>

          <td>The length of the data.</td>
        </tr>

        <tr>
          <td>N</td>

          <td>data</td>

          <td>The data itself. The actual field is padded to the next higher
          four bytes; for example, if length is 5 then 8 bytes are transmitted
          but only five bytes are relevant.</td>
        </tr>

        <tr>
          <td></td>

          <td></td>

          <td></td>
        </tr>
      </tbody>
    </informaltable>

    <para>It is possible that more information will be needed in the future;
    if so, the USC_version number should be bumped. For example we might
    decide to include a hash of the data in the record header.</para>
  </section>

  <section>
    <title>Open Questions</title>

    <itemizedlist>
      <listitem>
        <para>Is passing AVB data through the DD before it goes into the
        network going to give us adequate performance? And do we have any
        choice?</para>
      </listitem>

      <listitem>
        <para>Does including QoS with the LD make sense, or should there be a
        separate Quality Daemon (QD) dedicated to this? If so, how do they
        communicate?</para>
      </listitem>
    </itemizedlist>
  </section>
</article>
